{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.0.0\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { Component } from \"../../widgets/component\";\nimport { PopupEditorWrapper } from \"./../cellEditors/popupEditorWrapper\";\nimport { setAriaColIndex, setAriaDescribedBy, setAriaSelected, setAriaExpanded } from \"../../utils/aria\";\nimport { escapeString } from \"../../utils/string\";\nimport { missing } from \"../../utils/generic\";\nimport { addStylesToElement, clearElement, removeFromParent } from \"../../utils/dom\";\nimport { isBrowserIE } from \"../../utils/browser\";\n\nvar CellComp = function (_super) {\n  __extends(CellComp, _super);\n\n  function CellComp(scope, beans, cellCtrl, autoHeightCell, printLayout, eRow, editingRow) {\n    var _this = _super.call(this) || this;\n\n    _this.scope = null; // every time we go into edit mode, or back again, this gets incremented.\n    // it's the components way of dealing with the async nature of framework components,\n    // so if a framework component takes a while to be created, we know if the object\n    // is still relevant when creating is finished. eg we could click edit / un-edit 20\n    // times before the first React edit component comes back - we should discard\n    // the first 19.\n\n    _this.rendererVersion = 0;\n    _this.editorVersion = 0;\n    _this.scope = scope;\n    _this.beans = beans;\n    _this.column = cellCtrl.getColumn();\n    _this.rowNode = cellCtrl.getRowNode();\n    _this.rowCtrl = cellCtrl.getRowCtrl();\n    _this.autoHeightCell = autoHeightCell;\n    _this.eRow = eRow;\n\n    _this.setTemplate(\n    /* html */\n    \"<div comp-id=\\\"\" + _this.getCompId() + \"\\\"/>\");\n\n    var eGui = _this.getGui();\n\n    var style = eGui.style;\n    _this.eCellValue = eGui;\n\n    var setAttribute = function (name, value, element) {\n      var actualElement = element ? element : eGui;\n\n      if (value != null && value != '') {\n        actualElement.setAttribute(name, value);\n      } else {\n        actualElement.removeAttribute(name);\n      }\n    };\n\n    var compProxy = {\n      addOrRemoveCssClass: function (cssClassName, on) {\n        return _this.addOrRemoveCssClass(cssClassName, on);\n      },\n      setUserStyles: function (styles) {\n        return addStylesToElement(eGui, styles);\n      },\n      setAriaSelected: function (selected) {\n        return setAriaSelected(eGui, selected);\n      },\n      setAriaExpanded: function (selected) {\n        return setAriaExpanded(eGui, selected);\n      },\n      getFocusableElement: function () {\n        return _this.getFocusableElement();\n      },\n      setLeft: function (left) {\n        return style.left = left;\n      },\n      setWidth: function (width) {\n        return style.width = width;\n      },\n      setAriaColIndex: function (index) {\n        return setAriaColIndex(_this.getGui(), index);\n      },\n      setHeight: function (height) {\n        return style.height = height;\n      },\n      setZIndex: function (zIndex) {\n        return style.zIndex = zIndex;\n      },\n      setTabIndex: function (tabIndex) {\n        return setAttribute('tabindex', tabIndex.toString());\n      },\n      setRole: function (role) {\n        return setAttribute('role', role);\n      },\n      setColId: function (colId) {\n        return setAttribute('col-id', colId);\n      },\n      setTitle: function (title) {\n        return setAttribute('title', title);\n      },\n      setUnselectable: function (value) {\n        return setAttribute('unselectable', value, _this.eCellValue);\n      },\n      setTransition: function (transition) {\n        return style.transition = transition ? transition : '';\n      },\n      setIncludeSelection: function (include) {\n        return _this.includeSelection = include;\n      },\n      setIncludeRowDrag: function (include) {\n        return _this.includeRowDrag = include;\n      },\n      setIncludeDndSource: function (include) {\n        return _this.includeDndSource = include;\n      },\n      setForceWrapper: function (force) {\n        return _this.forceWrapper = force;\n      },\n      setRenderDetails: function (compDetails, valueToDisplay, force) {\n        return _this.setRenderDetails(compDetails, valueToDisplay, force);\n      },\n      setEditDetails: function (compDetails, popup, position) {\n        return _this.setEditDetails(compDetails, popup, position);\n      },\n      getCellEditor: function () {\n        return _this.cellEditor || null;\n      },\n      getCellRenderer: function () {\n        return _this.cellRenderer || null;\n      },\n      getParentOfValue: function () {\n        return _this.eCellValue;\n      }\n    };\n    _this.cellCtrl = cellCtrl;\n    cellCtrl.setComp(compProxy, _this.scope, _this.getGui(), printLayout, editingRow);\n    return _this;\n  }\n\n  CellComp.prototype.setRenderDetails = function (compDetails, valueToDisplay, forceNewCellRendererInstance) {\n    // this can happen if the users asks for the cell to refresh, but we are not showing the vale as we are editing\n    var isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;\n\n    if (isInlineEditing) {\n      return;\n    } // this means firstRender will be true for one pass only, as it's initialised to undefined\n\n\n    this.firstRender = this.firstRender == null;\n    var usingAngular1Template = this.isUsingAngular1Template(); // if display template has changed, means any previous Cell Renderer is in the wrong location\n\n    var controlWrapperChanged = this.setupControlsWrapper(); // all of these have dependencies on the eGui, so only do them after eGui is set\n\n    if (compDetails) {\n      var neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;\n      var cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);\n\n      if (!cellRendererRefreshSuccessful) {\n        this.destroyRenderer();\n        this.createCellRendererInstance(compDetails);\n      }\n    } else {\n      this.destroyRenderer();\n\n      if (usingAngular1Template) {\n        this.insertValueUsingAngular1Template();\n      } else {\n        this.insertValueWithoutCellRenderer(valueToDisplay);\n      }\n    }\n\n    this.cellCtrl.setupAutoHeight(this.eCellValue);\n  };\n\n  CellComp.prototype.setEditDetails = function (compDetails, popup, position) {\n    if (compDetails) {\n      this.createCellEditorInstance(compDetails, popup, position);\n    } else {\n      this.destroyEditor();\n    }\n  };\n\n  CellComp.prototype.removeControlsWrapper = function () {\n    this.eCellValue = this.getGui();\n    this.eCellWrapper = null;\n    this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp);\n    this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp);\n    this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);\n  }; // returns true if wrapper was changed\n\n\n  CellComp.prototype.setupControlsWrapper = function () {\n    var usingWrapper = this.includeRowDrag || this.includeDndSource || this.includeSelection || this.forceWrapper;\n    var changed = true;\n    var notChanged = false;\n    this.addOrRemoveCssClass('ag-cell-value', !usingWrapper); // turn wrapper on\n\n    if (usingWrapper && !this.eCellWrapper) {\n      this.addControlsWrapper();\n      return changed;\n    } // turn wrapper off\n\n\n    if (!usingWrapper && this.eCellWrapper) {\n      this.removeControlsWrapper();\n      return changed;\n    }\n\n    return notChanged;\n  };\n\n  CellComp.prototype.addControlsWrapper = function () {\n    var eGui = this.getGui();\n    eGui.innerHTML =\n    /* html */\n    \"<div ref=\\\"eCellWrapper\\\" class=\\\"ag-cell-wrapper\\\" role=\\\"presentation\\\">\\n                <span ref=\\\"eCellValue\\\" class=\\\"ag-cell-value\\\" role=\\\"presentation\\\"></span>\\n            </div>\";\n    this.eCellValue = this.getRefElement('eCellValue');\n    this.eCellWrapper = this.getRefElement('eCellWrapper');\n\n    if (!this.forceWrapper) {\n      this.eCellValue.setAttribute('unselectable', 'on');\n    }\n\n    var id = this.eCellValue.id = \"cell-\" + this.getCompId();\n    var describedByIds = [];\n\n    if (this.includeRowDrag) {\n      this.rowDraggingComp = this.cellCtrl.createRowDragComp();\n\n      if (this.rowDraggingComp) {\n        // put the checkbox in before the value\n        this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue);\n      }\n    }\n\n    if (this.includeDndSource) {\n      this.dndSourceComp = this.cellCtrl.createDndSource(); // put the checkbox in before the value\n\n      this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue);\n    }\n\n    if (this.includeSelection) {\n      this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox();\n      this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue);\n      describedByIds.push(this.checkboxSelectionComp.getCheckboxId());\n    }\n\n    describedByIds.push(id);\n    setAriaDescribedBy(this.getGui(), describedByIds.join(' '));\n  };\n\n  CellComp.prototype.createCellEditorInstance = function (compDetails, popup, position) {\n    var _this = this;\n\n    var versionCopy = this.editorVersion;\n    var cellEditorPromise = this.beans.userComponentFactory.createCellEditor(compDetails);\n\n    if (!cellEditorPromise) {\n      return;\n    } // if empty, userComponentFactory already did a console message\n\n\n    var params = compDetails.params;\n    cellEditorPromise.then(function (c) {\n      return _this.afterCellEditorCreated(versionCopy, c, params, popup, position);\n    }); // if we don't do this, and editor component is async, then there will be a period\n    // when the component isn't present and keyboard navigation won't work - so example\n    // of user hitting tab quickly (more quickly than renderers getting created) won't work\n\n    var cellEditorAsync = missing(this.cellEditor);\n\n    if (cellEditorAsync && params.cellStartedEdit) {\n      this.cellCtrl.focusCell(true);\n    }\n  };\n\n  CellComp.prototype.insertValueWithoutCellRenderer = function (valueToDisplay) {\n    var escapedValue = valueToDisplay != null ? escapeString(valueToDisplay) : null;\n\n    if (escapedValue != null) {\n      this.eCellValue.innerHTML = escapedValue;\n    } else {\n      clearElement(this.eCellValue);\n    }\n  };\n\n  CellComp.prototype.insertValueUsingAngular1Template = function () {\n    var _this = this;\n\n    var _a = this.column.getColDef(),\n        template = _a.template,\n        templateUrl = _a.templateUrl;\n\n    var templateToInsert = undefined;\n\n    if (template != null) {\n      templateToInsert = template;\n    } else if (templateUrl != null) {\n      // first time this happens it will return nothing, as the template will still be loading async,\n      // however once loaded it will refresh the cell and second time around it will be returned sync\n      // as in cache.\n      templateToInsert = this.beans.templateService.getTemplate(templateUrl, function () {\n        return _this.cellCtrl.refreshCell({\n          forceRefresh: true\n        });\n      });\n    } else {// should never happen, as we only enter this method when template or templateUrl exist\n    }\n\n    if (templateToInsert != null) {\n      this.eCellValue.innerHTML = templateToInsert;\n      this.updateAngular1ScopeAndCompile();\n    }\n  };\n\n  CellComp.prototype.destroyEditorAndRenderer = function () {\n    this.destroyRenderer();\n    this.destroyEditor();\n  };\n\n  CellComp.prototype.destroyRenderer = function () {\n    var context = this.beans.context;\n    this.cellRenderer = context.destroyBean(this.cellRenderer);\n    removeFromParent(this.cellRendererGui);\n    this.cellRendererGui = null;\n    this.rendererVersion++;\n  };\n\n  CellComp.prototype.destroyEditor = function () {\n    var context = this.beans.context;\n\n    if (this.hideEditorPopup) {\n      this.hideEditorPopup();\n    }\n\n    this.hideEditorPopup = undefined;\n    this.cellEditor = context.destroyBean(this.cellEditor);\n    this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);\n    removeFromParent(this.cellEditorGui);\n    this.cellEditorGui = null;\n    this.editorVersion++;\n  };\n\n  CellComp.prototype.refreshCellRenderer = function (compClassAndParams) {\n    if (this.cellRenderer == null || this.cellRenderer.refresh == null) {\n      return false;\n    } // if different Cell Renderer configured this time (eg user is using selector, and\n    // returns different component) then don't refresh, force recreate of Cell Renderer\n\n\n    if (this.cellRendererClass !== compClassAndParams.componentClass) {\n      return false;\n    } // take any custom params off of the user\n\n\n    var result = this.cellRenderer.refresh(compClassAndParams.params); // NOTE on undefined: previous version of the cellRenderer.refresh() interface\n    // returned nothing, if the method existed, we assumed it refreshed. so for\n    // backwards compatibility, we assume if method exists and returns nothing,\n    // that it was successful.\n\n    return result === true || result === undefined;\n  };\n\n  CellComp.prototype.createCellRendererInstance = function (compClassAndParams) {\n    var _this = this; // never use task service if angularCompileRows=true, as that assume the cell renderers\n    // are finished when the row is created. also we never use it if animation frame service\n    // is turned off.\n    // and lastly we never use it if doing auto-height, as the auto-height service checks the\n    // row height directly after the cell is created, it doesn't wait around for the tasks to complete\n\n\n    var angularCompileRows = this.beans.gridOptionsWrapper.isAngularCompileRows();\n    var suppressAnimationFrame = this.beans.gridOptionsWrapper.isSuppressAnimationFrame();\n    var useTaskService = !angularCompileRows && !suppressAnimationFrame && !this.autoHeightCell;\n    var displayComponentVersionCopy = this.rendererVersion;\n    var componentClass = compClassAndParams.componentClass;\n\n    var createCellRendererFunc = function () {\n      var staleTask = _this.rendererVersion !== displayComponentVersionCopy || !_this.isAlive();\n\n      if (staleTask) {\n        return;\n      } // this can return null in the event that the user has switched from a renderer component to nothing, for example\n      // when using a cellRendererSelect to return a component or null depending on row data etc\n\n\n      var componentPromise = _this.beans.userComponentFactory.createCellRenderer(compClassAndParams);\n\n      var callback = _this.afterCellRendererCreated.bind(_this, displayComponentVersionCopy, componentClass);\n\n      if (componentPromise) {\n        componentPromise.then(callback);\n      }\n    }; // we only use task service when rendering for first time, which means it is not used when doing edits.\n    // if we changed this (always use task service) would make sense, however it would break tests, possibly\n    // test of users.\n\n\n    if (useTaskService && this.firstRender) {\n      this.beans.taskQueue.createTask(createCellRendererFunc, this.rowNode.rowIndex, 'createTasksP2');\n    } else {\n      createCellRendererFunc();\n    }\n  };\n\n  CellComp.prototype.isUsingAngular1Template = function () {\n    var colDef = this.column.getColDef();\n    var res = colDef.template != null || colDef.templateUrl != null;\n    return res;\n  };\n\n  CellComp.prototype.getCtrl = function () {\n    return this.cellCtrl;\n  };\n\n  CellComp.prototype.getRowCtrl = function () {\n    return this.rowCtrl;\n  };\n\n  CellComp.prototype.getCellRenderer = function () {\n    return this.cellRenderer;\n  };\n\n  CellComp.prototype.getCellEditor = function () {\n    return this.cellEditor;\n  };\n\n  CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRendererClass, cellRenderer) {\n    var staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;\n\n    if (staleTask) {\n      this.beans.context.destroyBean(cellRenderer);\n      return;\n    }\n\n    this.cellRenderer = cellRenderer;\n    this.cellRendererClass = cellRendererClass;\n    this.cellRendererGui = this.cellRenderer.getGui();\n\n    if (this.cellRendererGui != null) {\n      clearElement(this.eCellValue);\n      this.eCellValue.appendChild(this.cellRendererGui);\n      this.updateAngular1ScopeAndCompile();\n    }\n  };\n\n  CellComp.prototype.afterCellEditorCreated = function (requestVersion, cellEditor, params, popup, position) {\n    // if editingCell=false, means user cancelled the editor before component was ready.\n    // if versionMismatch, then user cancelled the edit, then started the edit again, and this\n    //   is the first editor which is now stale.\n    var staleComp = requestVersion !== this.editorVersion;\n\n    if (staleComp) {\n      this.beans.context.destroyBean(cellEditor);\n      return;\n    }\n\n    var editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();\n\n    if (editingCancelledByUserComp) {\n      this.beans.context.destroyBean(cellEditor);\n      this.cellCtrl.stopEditing();\n      return;\n    }\n\n    if (!cellEditor.getGui) {\n      console.warn(\"AG Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\");\n      this.beans.context.destroyBean(cellEditor);\n      return;\n    }\n\n    this.cellEditor = cellEditor;\n    this.cellEditorGui = cellEditor.getGui();\n    var cellEditorInPopup = popup || cellEditor.isPopup !== undefined && cellEditor.isPopup();\n\n    if (cellEditorInPopup) {\n      if (!popup) {\n        this.cellCtrl.hackSayEditingInPopup();\n      }\n\n      this.addPopupCellEditor(params, position);\n    } else {\n      this.addInCellEditor();\n    }\n\n    if (cellEditor.afterGuiAttached) {\n      cellEditor.afterGuiAttached();\n    }\n  };\n\n  CellComp.prototype.addInCellEditor = function () {\n    var eGui = this.getGui(); // if focus is inside the cell, we move focus to the cell itself\n    // before removing it's contents, otherwise errors could be thrown.\n\n    if (eGui.contains(document.activeElement)) {\n      eGui.focus();\n    }\n\n    this.destroyRenderer();\n    this.removeControlsWrapper();\n    this.clearCellElement();\n\n    if (this.cellEditorGui) {\n      eGui.appendChild(this.cellEditorGui);\n    }\n  };\n\n  CellComp.prototype.addPopupCellEditor = function (params, position) {\n    var _this = this;\n\n    if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n      console.warn('AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' + '- either turn off fullRowEdit, or stop using popup editors.');\n    }\n\n    var cellEditor = this.cellEditor; // if a popup, then we wrap in a popup editor and return the popup\n\n    this.cellEditorPopupWrapper = this.beans.context.createBean(new PopupEditorWrapper(params));\n    var ePopupGui = this.cellEditorPopupWrapper.getGui();\n\n    if (this.cellEditorGui) {\n      ePopupGui.appendChild(this.cellEditorGui);\n    }\n\n    var popupService = this.beans.popupService;\n    var useModelPopup = this.beans.gridOptionsWrapper.isStopEditingWhenCellsLoseFocus(); // see if position provided by colDef, if not then check old way of method on cellComp\n\n    var positionToUse = position != null ? position : cellEditor.getPopupPosition ? cellEditor.getPopupPosition() : 'over';\n    var positionParams = {\n      column: this.column,\n      rowNode: this.rowNode,\n      type: 'popupCellEditor',\n      eventSource: this.getGui(),\n      ePopup: ePopupGui,\n      keepWithinBounds: true\n    };\n    var positionCallback = position === 'under' ? popupService.positionPopupUnderComponent.bind(popupService, positionParams) : popupService.positionPopupOverComponent.bind(popupService, positionParams);\n    var addPopupRes = popupService.addPopup({\n      modal: useModelPopup,\n      eChild: ePopupGui,\n      closeOnEsc: true,\n      closedCallback: function () {\n        _this.cellCtrl.onPopupEditorClosed();\n      },\n      anchorToElement: this.getGui(),\n      positionCallback: positionCallback\n    });\n\n    if (addPopupRes) {\n      this.hideEditorPopup = addPopupRes.hideFunc;\n    }\n  };\n\n  CellComp.prototype.detach = function () {\n    this.eRow.removeChild(this.getGui());\n  }; // if the row is also getting destroyed, then we don't need to remove from dom,\n  // as the row will also get removed, so no need to take out the cells from the row\n  // if the row is going (removing is an expensive operation, so only need to remove\n  // the top part)\n  //\n  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.\n\n\n  CellComp.prototype.destroy = function () {\n    this.cellCtrl.stopEditing();\n    this.destroyEditorAndRenderer();\n    this.removeControlsWrapper();\n\n    if (this.angularCompiledElement) {\n      this.angularCompiledElement.remove();\n      this.angularCompiledElement = undefined;\n    }\n\n    _super.prototype.destroy.call(this);\n  };\n\n  CellComp.prototype.clearCellElement = function () {\n    var eGui = this.getGui(); // if focus is inside the cell, we move focus to the cell itself\n    // before removing it's contents, otherwise errors could be thrown.\n\n    if (eGui.contains(document.activeElement) && !isBrowserIE()) {\n      eGui.focus({\n        preventScroll: true\n      });\n    }\n\n    clearElement(eGui);\n  };\n\n  CellComp.prototype.updateAngular1ScopeAndCompile = function () {\n    if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {\n      this.scope.data = __assign({}, this.rowNode.data);\n\n      if (this.angularCompiledElement) {\n        this.angularCompiledElement.remove();\n      }\n\n      this.angularCompiledElement = this.beans.$compile(this.eCellValue.children)(this.scope); // because this.scope is set, we are guaranteed GridBodyComp is vanilla JS, ie it's GridBodyComp.ts from AG Stack and and not react\n\n      this.beans.ctrlsService.getGridBodyCtrl().requestAngularApply();\n    }\n  };\n\n  return CellComp;\n}(Component);\n\nexport { CellComp };","map":{"version":3,"sources":["/Users/mphelps/react-app/TasQDashboard-main/node_modules/@ag-grid-community/core/dist/es6/rendering/cell/cellComp.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","Component","PopupEditorWrapper","setAriaColIndex","setAriaDescribedBy","setAriaSelected","setAriaExpanded","escapeString","missing","addStylesToElement","clearElement","removeFromParent","isBrowserIE","CellComp","_super","scope","beans","cellCtrl","autoHeightCell","printLayout","eRow","editingRow","_this","rendererVersion","editorVersion","column","getColumn","rowNode","getRowNode","rowCtrl","getRowCtrl","setTemplate","getCompId","eGui","getGui","style","eCellValue","setAttribute","name","value","element","actualElement","removeAttribute","compProxy","addOrRemoveCssClass","cssClassName","on","setUserStyles","styles","selected","getFocusableElement","setLeft","left","setWidth","width","index","setHeight","height","setZIndex","zIndex","setTabIndex","tabIndex","toString","setRole","role","setColId","colId","setTitle","title","setUnselectable","setTransition","transition","setIncludeSelection","include","includeSelection","setIncludeRowDrag","includeRowDrag","setIncludeDndSource","includeDndSource","setForceWrapper","force","forceWrapper","setRenderDetails","compDetails","valueToDisplay","setEditDetails","popup","position","getCellEditor","cellEditor","getCellRenderer","cellRenderer","getParentOfValue","setComp","forceNewCellRendererInstance","isInlineEditing","cellEditorPopupWrapper","firstRender","usingAngular1Template","isUsingAngular1Template","controlWrapperChanged","setupControlsWrapper","neverRefresh","cellRendererRefreshSuccessful","refreshCellRenderer","destroyRenderer","createCellRendererInstance","insertValueUsingAngular1Template","insertValueWithoutCellRenderer","setupAutoHeight","createCellEditorInstance","destroyEditor","removeControlsWrapper","eCellWrapper","checkboxSelectionComp","context","destroyBean","dndSourceComp","rowDraggingComp","usingWrapper","changed","notChanged","addControlsWrapper","innerHTML","getRefElement","id","describedByIds","createRowDragComp","insertBefore","createDndSource","createSelectionCheckbox","push","getCheckboxId","join","versionCopy","cellEditorPromise","userComponentFactory","createCellEditor","params","then","c","afterCellEditorCreated","cellEditorAsync","cellStartedEdit","focusCell","escapedValue","_a","getColDef","template","templateUrl","templateToInsert","undefined","templateService","getTemplate","refreshCell","forceRefresh","updateAngular1ScopeAndCompile","destroyEditorAndRenderer","cellRendererGui","hideEditorPopup","cellEditorGui","compClassAndParams","refresh","cellRendererClass","componentClass","result","angularCompileRows","gridOptionsWrapper","isAngularCompileRows","suppressAnimationFrame","isSuppressAnimationFrame","useTaskService","displayComponentVersionCopy","createCellRendererFunc","staleTask","isAlive","componentPromise","createCellRenderer","callback","afterCellRendererCreated","bind","taskQueue","createTask","rowIndex","colDef","res","getCtrl","cellRendererVersion","appendChild","requestVersion","staleComp","editingCancelledByUserComp","isCancelBeforeStart","stopEditing","console","warn","getId","cellEditorInPopup","isPopup","hackSayEditingInPopup","addPopupCellEditor","addInCellEditor","afterGuiAttached","contains","document","activeElement","focus","clearCellElement","isFullRowEdit","createBean","ePopupGui","popupService","useModelPopup","isStopEditingWhenCellsLoseFocus","positionToUse","getPopupPosition","positionParams","type","eventSource","ePopup","keepWithinBounds","positionCallback","positionPopupUnderComponent","positionPopupOverComponent","addPopupRes","addPopup","modal","eChild","closeOnEsc","closedCallback","onPopupEditorClosed","anchorToElement","hideFunc","detach","removeChild","destroy","angularCompiledElement","remove","preventScroll","data","$compile","children","ctrlsService","getGridBodyCtrl","requestAngularApply"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaA,IAAII,QAAQ,GAAI,QAAQ,KAAKA,QAAd,IAA2B,YAAY;AAClDA,EAAAA,QAAQ,GAAGV,MAAM,CAACW,MAAP,IAAiB,UAASC,CAAT,EAAY;AACpC,SAAK,IAAIC,CAAJ,EAAOC,CAAC,GAAG,CAAX,EAAcC,CAAC,GAAGC,SAAS,CAACC,MAAjC,EAAyCH,CAAC,GAAGC,CAA7C,EAAgDD,CAAC,EAAjD,EAAqD;AACjDD,MAAAA,CAAC,GAAGG,SAAS,CAACF,CAAD,CAAb;;AACA,WAAK,IAAIV,CAAT,IAAcS,CAAd,EAAiB,IAAIb,MAAM,CAACQ,SAAP,CAAiBH,cAAjB,CAAgCa,IAAhC,CAAqCL,CAArC,EAAwCT,CAAxC,CAAJ,EACbQ,CAAC,CAACR,CAAD,CAAD,GAAOS,CAAC,CAACT,CAAD,CAAR;AACP;;AACD,WAAOQ,CAAP;AACH,GAPD;;AAQA,SAAOF,QAAQ,CAACS,KAAT,CAAe,IAAf,EAAqBH,SAArB,CAAP;AACH,CAVD;;AAWA,SAASI,SAAT,QAA0B,yBAA1B;AACA,SAASC,kBAAT,QAAmC,qCAAnC;AACA,SAASC,eAAT,EAA0BC,kBAA1B,EAA8CC,eAA9C,EAA+DC,eAA/D,QAAsF,kBAAtF;AACA,SAASC,YAAT,QAA6B,oBAA7B;AACA,SAASC,OAAT,QAAwB,qBAAxB;AACA,SAASC,kBAAT,EAA6BC,YAA7B,EAA2CC,gBAA3C,QAAmE,iBAAnE;AACA,SAASC,WAAT,QAA4B,qBAA5B;;AACA,IAAIC,QAAQ,GAAkB,UAAUC,MAAV,EAAkB;AAC5CrC,EAAAA,SAAS,CAACoC,QAAD,EAAWC,MAAX,CAAT;;AACA,WAASD,QAAT,CAAkBE,KAAlB,EAAyBC,KAAzB,EAAgCC,QAAhC,EAA0CC,cAA1C,EAA0DC,WAA1D,EAAuEC,IAAvE,EAA6EC,UAA7E,EAAyF;AACrF,QAAIC,KAAK,GAAGR,MAAM,CAACf,IAAP,CAAY,IAAZ,KAAqB,IAAjC;;AACAuB,IAAAA,KAAK,CAACP,KAAN,GAAc,IAAd,CAFqF,CAGrF;AACA;AACA;AACA;AACA;AACA;;AACAO,IAAAA,KAAK,CAACC,eAAN,GAAwB,CAAxB;AACAD,IAAAA,KAAK,CAACE,aAAN,GAAsB,CAAtB;AACAF,IAAAA,KAAK,CAACP,KAAN,GAAcA,KAAd;AACAO,IAAAA,KAAK,CAACN,KAAN,GAAcA,KAAd;AACAM,IAAAA,KAAK,CAACG,MAAN,GAAeR,QAAQ,CAACS,SAAT,EAAf;AACAJ,IAAAA,KAAK,CAACK,OAAN,GAAgBV,QAAQ,CAACW,UAAT,EAAhB;AACAN,IAAAA,KAAK,CAACO,OAAN,GAAgBZ,QAAQ,CAACa,UAAT,EAAhB;AACAR,IAAAA,KAAK,CAACJ,cAAN,GAAuBA,cAAvB;AACAI,IAAAA,KAAK,CAACF,IAAN,GAAaA,IAAb;;AACAE,IAAAA,KAAK,CAACS,WAAN;AAAkB;AAAW,wBAAoBT,KAAK,CAACU,SAAN,EAApB,GAAwC,MAArE;;AACA,QAAIC,IAAI,GAAGX,KAAK,CAACY,MAAN,EAAX;;AACA,QAAIC,KAAK,GAAGF,IAAI,CAACE,KAAjB;AACAb,IAAAA,KAAK,CAACc,UAAN,GAAmBH,IAAnB;;AACA,QAAII,YAAY,GAAG,UAAUC,IAAV,EAAgBC,KAAhB,EAAuBC,OAAvB,EAAgC;AAC/C,UAAIC,aAAa,GAAGD,OAAO,GAAGA,OAAH,GAAaP,IAAxC;;AACA,UAAIM,KAAK,IAAI,IAAT,IAAiBA,KAAK,IAAI,EAA9B,EAAkC;AAC9BE,QAAAA,aAAa,CAACJ,YAAd,CAA2BC,IAA3B,EAAiCC,KAAjC;AACH,OAFD,MAGK;AACDE,QAAAA,aAAa,CAACC,eAAd,CAA8BJ,IAA9B;AACH;AACJ,KARD;;AASA,QAAIK,SAAS,GAAG;AACZC,MAAAA,mBAAmB,EAAE,UAAUC,YAAV,EAAwBC,EAAxB,EAA4B;AAAE,eAAOxB,KAAK,CAACsB,mBAAN,CAA0BC,YAA1B,EAAwCC,EAAxC,CAAP;AAAqD,OAD5F;AAEZC,MAAAA,aAAa,EAAE,UAAUC,MAAV,EAAkB;AAAE,eAAOvC,kBAAkB,CAACwB,IAAD,EAAOe,MAAP,CAAzB;AAA0C,OAFjE;AAGZ3C,MAAAA,eAAe,EAAE,UAAU4C,QAAV,EAAoB;AAAE,eAAO5C,eAAe,CAAC4B,IAAD,EAAOgB,QAAP,CAAtB;AAAyC,OAHpE;AAIZ3C,MAAAA,eAAe,EAAE,UAAU2C,QAAV,EAAoB;AAAE,eAAO3C,eAAe,CAAC2B,IAAD,EAAOgB,QAAP,CAAtB;AAAyC,OAJpE;AAKZC,MAAAA,mBAAmB,EAAE,YAAY;AAAE,eAAO5B,KAAK,CAAC4B,mBAAN,EAAP;AAAqC,OAL5D;AAMZC,MAAAA,OAAO,EAAE,UAAUC,IAAV,EAAgB;AAAE,eAAOjB,KAAK,CAACiB,IAAN,GAAaA,IAApB;AAA2B,OAN1C;AAOZC,MAAAA,QAAQ,EAAE,UAAUC,KAAV,EAAiB;AAAE,eAAOnB,KAAK,CAACmB,KAAN,GAAcA,KAArB;AAA6B,OAP9C;AAQZnD,MAAAA,eAAe,EAAE,UAAUoD,KAAV,EAAiB;AAAE,eAAOpD,eAAe,CAACmB,KAAK,CAACY,MAAN,EAAD,EAAiBqB,KAAjB,CAAtB;AAAgD,OARxE;AASZC,MAAAA,SAAS,EAAE,UAAUC,MAAV,EAAkB;AAAE,eAAOtB,KAAK,CAACsB,MAAN,GAAeA,MAAtB;AAA+B,OATlD;AAUZC,MAAAA,SAAS,EAAE,UAAUC,MAAV,EAAkB;AAAE,eAAOxB,KAAK,CAACwB,MAAN,GAAeA,MAAtB;AAA+B,OAVlD;AAWZC,MAAAA,WAAW,EAAE,UAAUC,QAAV,EAAoB;AAAE,eAAOxB,YAAY,CAAC,UAAD,EAAawB,QAAQ,CAACC,QAAT,EAAb,CAAnB;AAAuD,OAX9E;AAYZC,MAAAA,OAAO,EAAE,UAAUC,IAAV,EAAgB;AAAE,eAAO3B,YAAY,CAAC,MAAD,EAAS2B,IAAT,CAAnB;AAAoC,OAZnD;AAaZC,MAAAA,QAAQ,EAAE,UAAUC,KAAV,EAAiB;AAAE,eAAO7B,YAAY,CAAC,QAAD,EAAW6B,KAAX,CAAnB;AAAuC,OAbxD;AAcZC,MAAAA,QAAQ,EAAE,UAAUC,KAAV,EAAiB;AAAE,eAAO/B,YAAY,CAAC,OAAD,EAAU+B,KAAV,CAAnB;AAAsC,OAdvD;AAeZC,MAAAA,eAAe,EAAE,UAAU9B,KAAV,EAAiB;AAAE,eAAOF,YAAY,CAAC,cAAD,EAAiBE,KAAjB,EAAwBjB,KAAK,CAACc,UAA9B,CAAnB;AAA+D,OAfvF;AAgBZkC,MAAAA,aAAa,EAAE,UAAUC,UAAV,EAAsB;AAAE,eAAOpC,KAAK,CAACoC,UAAN,GAAmBA,UAAU,GAAGA,UAAH,GAAgB,EAApD;AAAyD,OAhBpF;AAiBZC,MAAAA,mBAAmB,EAAE,UAAUC,OAAV,EAAmB;AAAE,eAAOnD,KAAK,CAACoD,gBAAN,GAAyBD,OAAhC;AAA0C,OAjBxE;AAkBZE,MAAAA,iBAAiB,EAAE,UAAUF,OAAV,EAAmB;AAAE,eAAOnD,KAAK,CAACsD,cAAN,GAAuBH,OAA9B;AAAwC,OAlBpE;AAmBZI,MAAAA,mBAAmB,EAAE,UAAUJ,OAAV,EAAmB;AAAE,eAAOnD,KAAK,CAACwD,gBAAN,GAAyBL,OAAhC;AAA0C,OAnBxE;AAoBZM,MAAAA,eAAe,EAAE,UAAUC,KAAV,EAAiB;AAAE,eAAO1D,KAAK,CAAC2D,YAAN,GAAqBD,KAA5B;AAAoC,OApB5D;AAqBZE,MAAAA,gBAAgB,EAAE,UAAUC,WAAV,EAAuBC,cAAvB,EAAuCJ,KAAvC,EAA8C;AAC5D,eAAO1D,KAAK,CAAC4D,gBAAN,CAAuBC,WAAvB,EAAoCC,cAApC,EAAoDJ,KAApD,CAAP;AACH,OAvBW;AAwBZK,MAAAA,cAAc,EAAE,UAAUF,WAAV,EAAuBG,KAAvB,EAA8BC,QAA9B,EAAwC;AACpD,eAAOjE,KAAK,CAAC+D,cAAN,CAAqBF,WAArB,EAAkCG,KAAlC,EAAyCC,QAAzC,CAAP;AACH,OA1BW;AA2BZC,MAAAA,aAAa,EAAE,YAAY;AAAE,eAAOlE,KAAK,CAACmE,UAAN,IAAoB,IAA3B;AAAkC,OA3BnD;AA4BZC,MAAAA,eAAe,EAAE,YAAY;AAAE,eAAOpE,KAAK,CAACqE,YAAN,IAAsB,IAA7B;AAAoC,OA5BvD;AA6BZC,MAAAA,gBAAgB,EAAE,YAAY;AAAE,eAAOtE,KAAK,CAACc,UAAb;AAA0B;AA7B9C,KAAhB;AA+BAd,IAAAA,KAAK,CAACL,QAAN,GAAiBA,QAAjB;AACAA,IAAAA,QAAQ,CAAC4E,OAAT,CAAiBlD,SAAjB,EAA4BrB,KAAK,CAACP,KAAlC,EAAyCO,KAAK,CAACY,MAAN,EAAzC,EAAyDf,WAAzD,EAAsEE,UAAtE;AACA,WAAOC,KAAP;AACH;;AACDT,EAAAA,QAAQ,CAACxB,SAAT,CAAmB6F,gBAAnB,GAAsC,UAAUC,WAAV,EAAuBC,cAAvB,EAAuCU,4BAAvC,EAAqE;AACvG;AACA,QAAIC,eAAe,GAAG,KAAKN,UAAL,IAAmB,CAAC,KAAKO,sBAA/C;;AACA,QAAID,eAAJ,EAAqB;AACjB;AACH,KALsG,CAMvG;;;AACA,SAAKE,WAAL,GAAmB,KAAKA,WAAL,IAAoB,IAAvC;AACA,QAAIC,qBAAqB,GAAG,KAAKC,uBAAL,EAA5B,CARuG,CASvG;;AACA,QAAIC,qBAAqB,GAAG,KAAKC,oBAAL,EAA5B,CAVuG,CAWvG;;AACA,QAAIlB,WAAJ,EAAiB;AACb,UAAImB,YAAY,GAAGR,4BAA4B,IAAIM,qBAAnD;AACA,UAAIG,6BAA6B,GAAGD,YAAY,GAAG,KAAH,GAAW,KAAKE,mBAAL,CAAyBrB,WAAzB,CAA3D;;AACA,UAAI,CAACoB,6BAAL,EAAoC;AAChC,aAAKE,eAAL;AACA,aAAKC,0BAAL,CAAgCvB,WAAhC;AACH;AACJ,KAPD,MAQK;AACD,WAAKsB,eAAL;;AACA,UAAIP,qBAAJ,EAA2B;AACvB,aAAKS,gCAAL;AACH,OAFD,MAGK;AACD,aAAKC,8BAAL,CAAoCxB,cAApC;AACH;AACJ;;AACD,SAAKnE,QAAL,CAAc4F,eAAd,CAA8B,KAAKzE,UAAnC;AACH,GA9BD;;AA+BAvB,EAAAA,QAAQ,CAACxB,SAAT,CAAmBgG,cAAnB,GAAoC,UAAUF,WAAV,EAAuBG,KAAvB,EAA8BC,QAA9B,EAAwC;AACxE,QAAIJ,WAAJ,EAAiB;AACb,WAAK2B,wBAAL,CAA8B3B,WAA9B,EAA2CG,KAA3C,EAAkDC,QAAlD;AACH,KAFD,MAGK;AACD,WAAKwB,aAAL;AACH;AACJ,GAPD;;AAQAlG,EAAAA,QAAQ,CAACxB,SAAT,CAAmB2H,qBAAnB,GAA2C,YAAY;AACnD,SAAK5E,UAAL,GAAkB,KAAKF,MAAL,EAAlB;AACA,SAAK+E,YAAL,GAAoB,IAApB;AACA,SAAKC,qBAAL,GAA6B,KAAKlG,KAAL,CAAWmG,OAAX,CAAmBC,WAAnB,CAA+B,KAAKF,qBAApC,CAA7B;AACA,SAAKG,aAAL,GAAqB,KAAKrG,KAAL,CAAWmG,OAAX,CAAmBC,WAAnB,CAA+B,KAAKC,aAApC,CAArB;AACA,SAAKC,eAAL,GAAuB,KAAKtG,KAAL,CAAWmG,OAAX,CAAmBC,WAAnB,CAA+B,KAAKE,eAApC,CAAvB;AACH,GAND,CA3G4C,CAkH5C;;;AACAzG,EAAAA,QAAQ,CAACxB,SAAT,CAAmBgH,oBAAnB,GAA0C,YAAY;AAClD,QAAIkB,YAAY,GAAG,KAAK3C,cAAL,IAAuB,KAAKE,gBAA5B,IAAgD,KAAKJ,gBAArD,IAAyE,KAAKO,YAAjG;AACA,QAAIuC,OAAO,GAAG,IAAd;AACA,QAAIC,UAAU,GAAG,KAAjB;AACA,SAAK7E,mBAAL,CAAyB,eAAzB,EAA0C,CAAC2E,YAA3C,EAJkD,CAKlD;;AACA,QAAIA,YAAY,IAAI,CAAC,KAAKN,YAA1B,EAAwC;AACpC,WAAKS,kBAAL;AACA,aAAOF,OAAP;AACH,KATiD,CAUlD;;;AACA,QAAI,CAACD,YAAD,IAAiB,KAAKN,YAA1B,EAAwC;AACpC,WAAKD,qBAAL;AACA,aAAOQ,OAAP;AACH;;AACD,WAAOC,UAAP;AACH,GAhBD;;AAiBA5G,EAAAA,QAAQ,CAACxB,SAAT,CAAmBqI,kBAAnB,GAAwC,YAAY;AAChD,QAAIzF,IAAI,GAAG,KAAKC,MAAL,EAAX;AACAD,IAAAA,IAAI,CAAC0F,SAAL;AAAiB;AACb,oMADJ;AAEA,SAAKvF,UAAL,GAAkB,KAAKwF,aAAL,CAAmB,YAAnB,CAAlB;AACA,SAAKX,YAAL,GAAoB,KAAKW,aAAL,CAAmB,cAAnB,CAApB;;AACA,QAAI,CAAC,KAAK3C,YAAV,EAAwB;AACpB,WAAK7C,UAAL,CAAgBC,YAAhB,CAA6B,cAA7B,EAA6C,IAA7C;AACH;;AACD,QAAIwF,EAAE,GAAG,KAAKzF,UAAL,CAAgByF,EAAhB,GAAqB,UAAU,KAAK7F,SAAL,EAAxC;AACA,QAAI8F,cAAc,GAAG,EAArB;;AACA,QAAI,KAAKlD,cAAT,EAAyB;AACrB,WAAK0C,eAAL,GAAuB,KAAKrG,QAAL,CAAc8G,iBAAd,EAAvB;;AACA,UAAI,KAAKT,eAAT,EAA0B;AACtB;AACA,aAAKL,YAAL,CAAkBe,YAAlB,CAA+B,KAAKV,eAAL,CAAqBpF,MAArB,EAA/B,EAA8D,KAAKE,UAAnE;AACH;AACJ;;AACD,QAAI,KAAK0C,gBAAT,EAA2B;AACvB,WAAKuC,aAAL,GAAqB,KAAKpG,QAAL,CAAcgH,eAAd,EAArB,CADuB,CAEvB;;AACA,WAAKhB,YAAL,CAAkBe,YAAlB,CAA+B,KAAKX,aAAL,CAAmBnF,MAAnB,EAA/B,EAA4D,KAAKE,UAAjE;AACH;;AACD,QAAI,KAAKsC,gBAAT,EAA2B;AACvB,WAAKwC,qBAAL,GAA6B,KAAKjG,QAAL,CAAciH,uBAAd,EAA7B;AACA,WAAKjB,YAAL,CAAkBe,YAAlB,CAA+B,KAAKd,qBAAL,CAA2BhF,MAA3B,EAA/B,EAAoE,KAAKE,UAAzE;AACA0F,MAAAA,cAAc,CAACK,IAAf,CAAoB,KAAKjB,qBAAL,CAA2BkB,aAA3B,EAApB;AACH;;AACDN,IAAAA,cAAc,CAACK,IAAf,CAAoBN,EAApB;AACAzH,IAAAA,kBAAkB,CAAC,KAAK8B,MAAL,EAAD,EAAgB4F,cAAc,CAACO,IAAf,CAAoB,GAApB,CAAhB,CAAlB;AACH,GA9BD;;AA+BAxH,EAAAA,QAAQ,CAACxB,SAAT,CAAmByH,wBAAnB,GAA8C,UAAU3B,WAAV,EAAuBG,KAAvB,EAA8BC,QAA9B,EAAwC;AAClF,QAAIjE,KAAK,GAAG,IAAZ;;AACA,QAAIgH,WAAW,GAAG,KAAK9G,aAAvB;AACA,QAAI+G,iBAAiB,GAAG,KAAKvH,KAAL,CAAWwH,oBAAX,CAAgCC,gBAAhC,CAAiDtD,WAAjD,CAAxB;;AACA,QAAI,CAACoD,iBAAL,EAAwB;AACpB;AACH,KANiF,CAMhF;;;AACF,QAAIG,MAAM,GAAGvD,WAAW,CAACuD,MAAzB;AACAH,IAAAA,iBAAiB,CAACI,IAAlB,CAAuB,UAAUC,CAAV,EAAa;AAAE,aAAOtH,KAAK,CAACuH,sBAAN,CAA6BP,WAA7B,EAA0CM,CAA1C,EAA6CF,MAA7C,EAAqDpD,KAArD,EAA4DC,QAA5D,CAAP;AAA+E,KAArH,EARkF,CASlF;AACA;AACA;;AACA,QAAIuD,eAAe,GAAGtI,OAAO,CAAC,KAAKiF,UAAN,CAA7B;;AACA,QAAIqD,eAAe,IAAIJ,MAAM,CAACK,eAA9B,EAA+C;AAC3C,WAAK9H,QAAL,CAAc+H,SAAd,CAAwB,IAAxB;AACH;AACJ,GAhBD;;AAiBAnI,EAAAA,QAAQ,CAACxB,SAAT,CAAmBuH,8BAAnB,GAAoD,UAAUxB,cAAV,EAA0B;AAC1E,QAAI6D,YAAY,GAAG7D,cAAc,IAAI,IAAlB,GAAyB7E,YAAY,CAAC6E,cAAD,CAArC,GAAwD,IAA3E;;AACA,QAAI6D,YAAY,IAAI,IAApB,EAA0B;AACtB,WAAK7G,UAAL,CAAgBuF,SAAhB,GAA4BsB,YAA5B;AACH,KAFD,MAGK;AACDvI,MAAAA,YAAY,CAAC,KAAK0B,UAAN,CAAZ;AACH;AACJ,GARD;;AASAvB,EAAAA,QAAQ,CAACxB,SAAT,CAAmBsH,gCAAnB,GAAsD,YAAY;AAC9D,QAAIrF,KAAK,GAAG,IAAZ;;AACA,QAAI4H,EAAE,GAAG,KAAKzH,MAAL,CAAY0H,SAAZ,EAAT;AAAA,QAAkCC,QAAQ,GAAGF,EAAE,CAACE,QAAhD;AAAA,QAA0DC,WAAW,GAAGH,EAAE,CAACG,WAA3E;;AACA,QAAIC,gBAAgB,GAAGC,SAAvB;;AACA,QAAIH,QAAQ,IAAI,IAAhB,EAAsB;AAClBE,MAAAA,gBAAgB,GAAGF,QAAnB;AACH,KAFD,MAGK,IAAIC,WAAW,IAAI,IAAnB,EAAyB;AAC1B;AACA;AACA;AACAC,MAAAA,gBAAgB,GAAG,KAAKtI,KAAL,CAAWwI,eAAX,CAA2BC,WAA3B,CAAuCJ,WAAvC,EAAoD,YAAY;AAAE,eAAO/H,KAAK,CAACL,QAAN,CAAeyI,WAAf,CAA2B;AAAEC,UAAAA,YAAY,EAAE;AAAhB,SAA3B,CAAP;AAA4D,OAA9H,CAAnB;AACH,KALI,MAMA,CACD;AACH;;AACD,QAAIL,gBAAgB,IAAI,IAAxB,EAA8B;AAC1B,WAAKlH,UAAL,CAAgBuF,SAAhB,GAA4B2B,gBAA5B;AACA,WAAKM,6BAAL;AACH;AACJ,GApBD;;AAqBA/I,EAAAA,QAAQ,CAACxB,SAAT,CAAmBwK,wBAAnB,GAA8C,YAAY;AACtD,SAAKpD,eAAL;AACA,SAAKM,aAAL;AACH,GAHD;;AAIAlG,EAAAA,QAAQ,CAACxB,SAAT,CAAmBoH,eAAnB,GAAqC,YAAY;AAC7C,QAAIU,OAAO,GAAG,KAAKnG,KAAL,CAAWmG,OAAzB;AACA,SAAKxB,YAAL,GAAoBwB,OAAO,CAACC,WAAR,CAAoB,KAAKzB,YAAzB,CAApB;AACAhF,IAAAA,gBAAgB,CAAC,KAAKmJ,eAAN,CAAhB;AACA,SAAKA,eAAL,GAAuB,IAAvB;AACA,SAAKvI,eAAL;AACH,GAND;;AAOAV,EAAAA,QAAQ,CAACxB,SAAT,CAAmB0H,aAAnB,GAAmC,YAAY;AAC3C,QAAII,OAAO,GAAG,KAAKnG,KAAL,CAAWmG,OAAzB;;AACA,QAAI,KAAK4C,eAAT,EAA0B;AACtB,WAAKA,eAAL;AACH;;AACD,SAAKA,eAAL,GAAuBR,SAAvB;AACA,SAAK9D,UAAL,GAAkB0B,OAAO,CAACC,WAAR,CAAoB,KAAK3B,UAAzB,CAAlB;AACA,SAAKO,sBAAL,GAA8BmB,OAAO,CAACC,WAAR,CAAoB,KAAKpB,sBAAzB,CAA9B;AACArF,IAAAA,gBAAgB,CAAC,KAAKqJ,aAAN,CAAhB;AACA,SAAKA,aAAL,GAAqB,IAArB;AACA,SAAKxI,aAAL;AACH,GAXD;;AAYAX,EAAAA,QAAQ,CAACxB,SAAT,CAAmBmH,mBAAnB,GAAyC,UAAUyD,kBAAV,EAA8B;AACnE,QAAI,KAAKtE,YAAL,IAAqB,IAArB,IAA6B,KAAKA,YAAL,CAAkBuE,OAAlB,IAA6B,IAA9D,EAAoE;AAChE,aAAO,KAAP;AACH,KAHkE,CAInE;AACA;;;AACA,QAAI,KAAKC,iBAAL,KAA2BF,kBAAkB,CAACG,cAAlD,EAAkE;AAC9D,aAAO,KAAP;AACH,KARkE,CASnE;;;AACA,QAAIC,MAAM,GAAG,KAAK1E,YAAL,CAAkBuE,OAAlB,CAA0BD,kBAAkB,CAACvB,MAA7C,CAAb,CAVmE,CAWnE;AACA;AACA;AACA;;AACA,WAAO2B,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKd,SAArC;AACH,GAhBD;;AAiBA1I,EAAAA,QAAQ,CAACxB,SAAT,CAAmBqH,0BAAnB,GAAgD,UAAUuD,kBAAV,EAA8B;AAC1E,QAAI3I,KAAK,GAAG,IAAZ,CAD0E,CAE1E;AACA;AACA;AACA;AACA;;;AACA,QAAIgJ,kBAAkB,GAAG,KAAKtJ,KAAL,CAAWuJ,kBAAX,CAA8BC,oBAA9B,EAAzB;AACA,QAAIC,sBAAsB,GAAG,KAAKzJ,KAAL,CAAWuJ,kBAAX,CAA8BG,wBAA9B,EAA7B;AACA,QAAIC,cAAc,GAAG,CAACL,kBAAD,IAAuB,CAACG,sBAAxB,IAAkD,CAAC,KAAKvJ,cAA7E;AACA,QAAI0J,2BAA2B,GAAG,KAAKrJ,eAAvC;AACA,QAAI6I,cAAc,GAAGH,kBAAkB,CAACG,cAAxC;;AACA,QAAIS,sBAAsB,GAAG,YAAY;AACrC,UAAIC,SAAS,GAAGxJ,KAAK,CAACC,eAAN,KAA0BqJ,2BAA1B,IAAyD,CAACtJ,KAAK,CAACyJ,OAAN,EAA1E;;AACA,UAAID,SAAJ,EAAe;AACX;AACH,OAJoC,CAKrC;AACA;;;AACA,UAAIE,gBAAgB,GAAG1J,KAAK,CAACN,KAAN,CAAYwH,oBAAZ,CAAiCyC,kBAAjC,CAAoDhB,kBAApD,CAAvB;;AACA,UAAIiB,QAAQ,GAAG5J,KAAK,CAAC6J,wBAAN,CAA+BC,IAA/B,CAAoC9J,KAApC,EAA2CsJ,2BAA3C,EAAwER,cAAxE,CAAf;;AACA,UAAIY,gBAAJ,EAAsB;AAClBA,QAAAA,gBAAgB,CAACrC,IAAjB,CAAsBuC,QAAtB;AACH;AACJ,KAZD,CAZ0E,CAyB1E;AACA;AACA;;;AACA,QAAIP,cAAc,IAAI,KAAK1E,WAA3B,EAAwC;AACpC,WAAKjF,KAAL,CAAWqK,SAAX,CAAqBC,UAArB,CAAgCT,sBAAhC,EAAwD,KAAKlJ,OAAL,CAAa4J,QAArE,EAA+E,eAA/E;AACH,KAFD,MAGK;AACDV,MAAAA,sBAAsB;AACzB;AACJ,GAlCD;;AAmCAhK,EAAAA,QAAQ,CAACxB,SAAT,CAAmB8G,uBAAnB,GAA6C,YAAY;AACrD,QAAIqF,MAAM,GAAG,KAAK/J,MAAL,CAAY0H,SAAZ,EAAb;AACA,QAAIsC,GAAG,GAAGD,MAAM,CAACpC,QAAP,IAAmB,IAAnB,IAA2BoC,MAAM,CAACnC,WAAP,IAAsB,IAA3D;AACA,WAAOoC,GAAP;AACH,GAJD;;AAKA5K,EAAAA,QAAQ,CAACxB,SAAT,CAAmBqM,OAAnB,GAA6B,YAAY;AACrC,WAAO,KAAKzK,QAAZ;AACH,GAFD;;AAGAJ,EAAAA,QAAQ,CAACxB,SAAT,CAAmByC,UAAnB,GAAgC,YAAY;AACxC,WAAO,KAAKD,OAAZ;AACH,GAFD;;AAGAhB,EAAAA,QAAQ,CAACxB,SAAT,CAAmBqG,eAAnB,GAAqC,YAAY;AAC7C,WAAO,KAAKC,YAAZ;AACH,GAFD;;AAGA9E,EAAAA,QAAQ,CAACxB,SAAT,CAAmBmG,aAAnB,GAAmC,YAAY;AAC3C,WAAO,KAAKC,UAAZ;AACH,GAFD;;AAGA5E,EAAAA,QAAQ,CAACxB,SAAT,CAAmB8L,wBAAnB,GAA8C,UAAUQ,mBAAV,EAA+BxB,iBAA/B,EAAkDxE,YAAlD,EAAgE;AAC1G,QAAImF,SAAS,GAAG,CAAC,KAAKC,OAAL,EAAD,IAAmBY,mBAAmB,KAAK,KAAKpK,eAAhE;;AACA,QAAIuJ,SAAJ,EAAe;AACX,WAAK9J,KAAL,CAAWmG,OAAX,CAAmBC,WAAnB,CAA+BzB,YAA/B;AACA;AACH;;AACD,SAAKA,YAAL,GAAoBA,YAApB;AACA,SAAKwE,iBAAL,GAAyBA,iBAAzB;AACA,SAAKL,eAAL,GAAuB,KAAKnE,YAAL,CAAkBzD,MAAlB,EAAvB;;AACA,QAAI,KAAK4H,eAAL,IAAwB,IAA5B,EAAkC;AAC9BpJ,MAAAA,YAAY,CAAC,KAAK0B,UAAN,CAAZ;AACA,WAAKA,UAAL,CAAgBwJ,WAAhB,CAA4B,KAAK9B,eAAjC;AACA,WAAKF,6BAAL;AACH;AACJ,GAdD;;AAeA/I,EAAAA,QAAQ,CAACxB,SAAT,CAAmBwJ,sBAAnB,GAA4C,UAAUgD,cAAV,EAA0BpG,UAA1B,EAAsCiD,MAAtC,EAA8CpD,KAA9C,EAAqDC,QAArD,EAA+D;AACvG;AACA;AACA;AACA,QAAIuG,SAAS,GAAGD,cAAc,KAAK,KAAKrK,aAAxC;;AACA,QAAIsK,SAAJ,EAAe;AACX,WAAK9K,KAAL,CAAWmG,OAAX,CAAmBC,WAAnB,CAA+B3B,UAA/B;AACA;AACH;;AACD,QAAIsG,0BAA0B,GAAGtG,UAAU,CAACuG,mBAAX,IAAkCvG,UAAU,CAACuG,mBAAX,EAAnE;;AACA,QAAID,0BAAJ,EAAgC;AAC5B,WAAK/K,KAAL,CAAWmG,OAAX,CAAmBC,WAAnB,CAA+B3B,UAA/B;AACA,WAAKxE,QAAL,CAAcgL,WAAd;AACA;AACH;;AACD,QAAI,CAACxG,UAAU,CAACvD,MAAhB,EAAwB;AACpBgK,MAAAA,OAAO,CAACC,IAAR,CAAa,oCAAoC,KAAK1K,MAAL,CAAY2K,KAAZ,EAApC,GAA0D,6BAAvE;AACA,WAAKpL,KAAL,CAAWmG,OAAX,CAAmBC,WAAnB,CAA+B3B,UAA/B;AACA;AACH;;AACD,SAAKA,UAAL,GAAkBA,UAAlB;AACA,SAAKuE,aAAL,GAAqBvE,UAAU,CAACvD,MAAX,EAArB;AACA,QAAImK,iBAAiB,GAAG/G,KAAK,IAAKG,UAAU,CAAC6G,OAAX,KAAuB/C,SAAvB,IAAoC9D,UAAU,CAAC6G,OAAX,EAAtE;;AACA,QAAID,iBAAJ,EAAuB;AACnB,UAAI,CAAC/G,KAAL,EAAY;AACR,aAAKrE,QAAL,CAAcsL,qBAAd;AACH;;AACD,WAAKC,kBAAL,CAAwB9D,MAAxB,EAAgCnD,QAAhC;AACH,KALD,MAMK;AACD,WAAKkH,eAAL;AACH;;AACD,QAAIhH,UAAU,CAACiH,gBAAf,EAAiC;AAC7BjH,MAAAA,UAAU,CAACiH,gBAAX;AACH;AACJ,GAnCD;;AAoCA7L,EAAAA,QAAQ,CAACxB,SAAT,CAAmBoN,eAAnB,GAAqC,YAAY;AAC7C,QAAIxK,IAAI,GAAG,KAAKC,MAAL,EAAX,CAD6C,CAE7C;AACA;;AACA,QAAID,IAAI,CAAC0K,QAAL,CAAcC,QAAQ,CAACC,aAAvB,CAAJ,EAA2C;AACvC5K,MAAAA,IAAI,CAAC6K,KAAL;AACH;;AACD,SAAKrG,eAAL;AACA,SAAKO,qBAAL;AACA,SAAK+F,gBAAL;;AACA,QAAI,KAAK/C,aAAT,EAAwB;AACpB/H,MAAAA,IAAI,CAAC2J,WAAL,CAAiB,KAAK5B,aAAtB;AACH;AACJ,GAbD;;AAcAnJ,EAAAA,QAAQ,CAACxB,SAAT,CAAmBmN,kBAAnB,GAAwC,UAAU9D,MAAV,EAAkBnD,QAAlB,EAA4B;AAChE,QAAIjE,KAAK,GAAG,IAAZ;;AACA,QAAI,KAAKN,KAAL,CAAWuJ,kBAAX,CAA8ByC,aAA9B,EAAJ,EAAmD;AAC/Cd,MAAAA,OAAO,CAACC,IAAR,CAAa,yFACT,6DADJ;AAEH;;AACD,QAAI1G,UAAU,GAAG,KAAKA,UAAtB,CANgE,CAOhE;;AACA,SAAKO,sBAAL,GAA8B,KAAKhF,KAAL,CAAWmG,OAAX,CAAmB8F,UAAnB,CAA8B,IAAI/M,kBAAJ,CAAuBwI,MAAvB,CAA9B,CAA9B;AACA,QAAIwE,SAAS,GAAG,KAAKlH,sBAAL,CAA4B9D,MAA5B,EAAhB;;AACA,QAAI,KAAK8H,aAAT,EAAwB;AACpBkD,MAAAA,SAAS,CAACtB,WAAV,CAAsB,KAAK5B,aAA3B;AACH;;AACD,QAAImD,YAAY,GAAG,KAAKnM,KAAL,CAAWmM,YAA9B;AACA,QAAIC,aAAa,GAAG,KAAKpM,KAAL,CAAWuJ,kBAAX,CAA8B8C,+BAA9B,EAApB,CAdgE,CAehE;;AACA,QAAIC,aAAa,GAAG/H,QAAQ,IAAI,IAAZ,GAAmBA,QAAnB,GAA8BE,UAAU,CAAC8H,gBAAX,GAA8B9H,UAAU,CAAC8H,gBAAX,EAA9B,GAA8D,MAAhH;AACA,QAAIC,cAAc,GAAG;AACjB/L,MAAAA,MAAM,EAAE,KAAKA,MADI;AAEjBE,MAAAA,OAAO,EAAE,KAAKA,OAFG;AAGjB8L,MAAAA,IAAI,EAAE,iBAHW;AAIjBC,MAAAA,WAAW,EAAE,KAAKxL,MAAL,EAJI;AAKjByL,MAAAA,MAAM,EAAET,SALS;AAMjBU,MAAAA,gBAAgB,EAAE;AAND,KAArB;AAQA,QAAIC,gBAAgB,GAAGtI,QAAQ,KAAK,OAAb,GACnB4H,YAAY,CAACW,2BAAb,CAAyC1C,IAAzC,CAA8C+B,YAA9C,EAA4DK,cAA5D,CADmB,GAEjBL,YAAY,CAACY,0BAAb,CAAwC3C,IAAxC,CAA6C+B,YAA7C,EAA2DK,cAA3D,CAFN;AAGA,QAAIQ,WAAW,GAAGb,YAAY,CAACc,QAAb,CAAsB;AACpCC,MAAAA,KAAK,EAAEd,aAD6B;AAEpCe,MAAAA,MAAM,EAAEjB,SAF4B;AAGpCkB,MAAAA,UAAU,EAAE,IAHwB;AAIpCC,MAAAA,cAAc,EAAE,YAAY;AAAE/M,QAAAA,KAAK,CAACL,QAAN,CAAeqN,mBAAf;AAAuC,OAJjC;AAKpCC,MAAAA,eAAe,EAAE,KAAKrM,MAAL,EALmB;AAMpC2L,MAAAA,gBAAgB,EAAEA;AANkB,KAAtB,CAAlB;;AAQA,QAAIG,WAAJ,EAAiB;AACb,WAAKjE,eAAL,GAAuBiE,WAAW,CAACQ,QAAnC;AACH;AACJ,GAvCD;;AAwCA3N,EAAAA,QAAQ,CAACxB,SAAT,CAAmBoP,MAAnB,GAA4B,YAAY;AACpC,SAAKrN,IAAL,CAAUsN,WAAV,CAAsB,KAAKxM,MAAL,EAAtB;AACH,GAFD,CAvZ4C,CA0Z5C;AACA;AACA;AACA;AACA;AACA;;;AACArB,EAAAA,QAAQ,CAACxB,SAAT,CAAmBsP,OAAnB,GAA6B,YAAY;AACrC,SAAK1N,QAAL,CAAcgL,WAAd;AACA,SAAKpC,wBAAL;AACA,SAAK7C,qBAAL;;AACA,QAAI,KAAK4H,sBAAT,EAAiC;AAC7B,WAAKA,sBAAL,CAA4BC,MAA5B;AACA,WAAKD,sBAAL,GAA8BrF,SAA9B;AACH;;AACDzI,IAAAA,MAAM,CAACzB,SAAP,CAAiBsP,OAAjB,CAAyB5O,IAAzB,CAA8B,IAA9B;AACH,GATD;;AAUAc,EAAAA,QAAQ,CAACxB,SAAT,CAAmB0N,gBAAnB,GAAsC,YAAY;AAC9C,QAAI9K,IAAI,GAAG,KAAKC,MAAL,EAAX,CAD8C,CAE9C;AACA;;AACA,QAAID,IAAI,CAAC0K,QAAL,CAAcC,QAAQ,CAACC,aAAvB,KAAyC,CAACjM,WAAW,EAAzD,EAA6D;AACzDqB,MAAAA,IAAI,CAAC6K,KAAL,CAAW;AACPgC,QAAAA,aAAa,EAAE;AADR,OAAX;AAGH;;AACDpO,IAAAA,YAAY,CAACuB,IAAD,CAAZ;AACH,GAVD;;AAWApB,EAAAA,QAAQ,CAACxB,SAAT,CAAmBuK,6BAAnB,GAAmD,YAAY;AAC3D,QAAI,KAAK5I,KAAL,CAAWuJ,kBAAX,CAA8BC,oBAA9B,MAAwD,KAAKzJ,KAAjE,EAAwE;AACpE,WAAKA,KAAL,CAAWgO,IAAX,GAAkBxP,QAAQ,CAAC,EAAD,EAAK,KAAKoC,OAAL,CAAaoN,IAAlB,CAA1B;;AACA,UAAI,KAAKH,sBAAT,EAAiC;AAC7B,aAAKA,sBAAL,CAA4BC,MAA5B;AACH;;AACD,WAAKD,sBAAL,GAA8B,KAAK5N,KAAL,CAAWgO,QAAX,CAAoB,KAAK5M,UAAL,CAAgB6M,QAApC,EAA8C,KAAKlO,KAAnD,CAA9B,CALoE,CAMpE;;AACA,WAAKC,KAAL,CAAWkO,YAAX,CAAwBC,eAAxB,GAA0CC,mBAA1C;AACH;AACJ,GAVD;;AAWA,SAAOvO,QAAP;AACH,CAjc6B,CAic5BZ,SAjc4B,CAA9B;;AAkcA,SAASY,QAAT","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v26.0.0\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { Component } from \"../../widgets/component\";\nimport { PopupEditorWrapper } from \"./../cellEditors/popupEditorWrapper\";\nimport { setAriaColIndex, setAriaDescribedBy, setAriaSelected, setAriaExpanded } from \"../../utils/aria\";\nimport { escapeString } from \"../../utils/string\";\nimport { missing } from \"../../utils/generic\";\nimport { addStylesToElement, clearElement, removeFromParent } from \"../../utils/dom\";\nimport { isBrowserIE } from \"../../utils/browser\";\nvar CellComp = /** @class */ (function (_super) {\n    __extends(CellComp, _super);\n    function CellComp(scope, beans, cellCtrl, autoHeightCell, printLayout, eRow, editingRow) {\n        var _this = _super.call(this) || this;\n        _this.scope = null;\n        // every time we go into edit mode, or back again, this gets incremented.\n        // it's the components way of dealing with the async nature of framework components,\n        // so if a framework component takes a while to be created, we know if the object\n        // is still relevant when creating is finished. eg we could click edit / un-edit 20\n        // times before the first React edit component comes back - we should discard\n        // the first 19.\n        _this.rendererVersion = 0;\n        _this.editorVersion = 0;\n        _this.scope = scope;\n        _this.beans = beans;\n        _this.column = cellCtrl.getColumn();\n        _this.rowNode = cellCtrl.getRowNode();\n        _this.rowCtrl = cellCtrl.getRowCtrl();\n        _this.autoHeightCell = autoHeightCell;\n        _this.eRow = eRow;\n        _this.setTemplate(/* html */ \"<div comp-id=\\\"\" + _this.getCompId() + \"\\\"/>\");\n        var eGui = _this.getGui();\n        var style = eGui.style;\n        _this.eCellValue = eGui;\n        var setAttribute = function (name, value, element) {\n            var actualElement = element ? element : eGui;\n            if (value != null && value != '') {\n                actualElement.setAttribute(name, value);\n            }\n            else {\n                actualElement.removeAttribute(name);\n            }\n        };\n        var compProxy = {\n            addOrRemoveCssClass: function (cssClassName, on) { return _this.addOrRemoveCssClass(cssClassName, on); },\n            setUserStyles: function (styles) { return addStylesToElement(eGui, styles); },\n            setAriaSelected: function (selected) { return setAriaSelected(eGui, selected); },\n            setAriaExpanded: function (selected) { return setAriaExpanded(eGui, selected); },\n            getFocusableElement: function () { return _this.getFocusableElement(); },\n            setLeft: function (left) { return style.left = left; },\n            setWidth: function (width) { return style.width = width; },\n            setAriaColIndex: function (index) { return setAriaColIndex(_this.getGui(), index); },\n            setHeight: function (height) { return style.height = height; },\n            setZIndex: function (zIndex) { return style.zIndex = zIndex; },\n            setTabIndex: function (tabIndex) { return setAttribute('tabindex', tabIndex.toString()); },\n            setRole: function (role) { return setAttribute('role', role); },\n            setColId: function (colId) { return setAttribute('col-id', colId); },\n            setTitle: function (title) { return setAttribute('title', title); },\n            setUnselectable: function (value) { return setAttribute('unselectable', value, _this.eCellValue); },\n            setTransition: function (transition) { return style.transition = transition ? transition : ''; },\n            setIncludeSelection: function (include) { return _this.includeSelection = include; },\n            setIncludeRowDrag: function (include) { return _this.includeRowDrag = include; },\n            setIncludeDndSource: function (include) { return _this.includeDndSource = include; },\n            setForceWrapper: function (force) { return _this.forceWrapper = force; },\n            setRenderDetails: function (compDetails, valueToDisplay, force) {\n                return _this.setRenderDetails(compDetails, valueToDisplay, force);\n            },\n            setEditDetails: function (compDetails, popup, position) {\n                return _this.setEditDetails(compDetails, popup, position);\n            },\n            getCellEditor: function () { return _this.cellEditor || null; },\n            getCellRenderer: function () { return _this.cellRenderer || null; },\n            getParentOfValue: function () { return _this.eCellValue; }\n        };\n        _this.cellCtrl = cellCtrl;\n        cellCtrl.setComp(compProxy, _this.scope, _this.getGui(), printLayout, editingRow);\n        return _this;\n    }\n    CellComp.prototype.setRenderDetails = function (compDetails, valueToDisplay, forceNewCellRendererInstance) {\n        // this can happen if the users asks for the cell to refresh, but we are not showing the vale as we are editing\n        var isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;\n        if (isInlineEditing) {\n            return;\n        }\n        // this means firstRender will be true for one pass only, as it's initialised to undefined\n        this.firstRender = this.firstRender == null;\n        var usingAngular1Template = this.isUsingAngular1Template();\n        // if display template has changed, means any previous Cell Renderer is in the wrong location\n        var controlWrapperChanged = this.setupControlsWrapper();\n        // all of these have dependencies on the eGui, so only do them after eGui is set\n        if (compDetails) {\n            var neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;\n            var cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);\n            if (!cellRendererRefreshSuccessful) {\n                this.destroyRenderer();\n                this.createCellRendererInstance(compDetails);\n            }\n        }\n        else {\n            this.destroyRenderer();\n            if (usingAngular1Template) {\n                this.insertValueUsingAngular1Template();\n            }\n            else {\n                this.insertValueWithoutCellRenderer(valueToDisplay);\n            }\n        }\n        this.cellCtrl.setupAutoHeight(this.eCellValue);\n    };\n    CellComp.prototype.setEditDetails = function (compDetails, popup, position) {\n        if (compDetails) {\n            this.createCellEditorInstance(compDetails, popup, position);\n        }\n        else {\n            this.destroyEditor();\n        }\n    };\n    CellComp.prototype.removeControlsWrapper = function () {\n        this.eCellValue = this.getGui();\n        this.eCellWrapper = null;\n        this.checkboxSelectionComp = this.beans.context.destroyBean(this.checkboxSelectionComp);\n        this.dndSourceComp = this.beans.context.destroyBean(this.dndSourceComp);\n        this.rowDraggingComp = this.beans.context.destroyBean(this.rowDraggingComp);\n    };\n    // returns true if wrapper was changed\n    CellComp.prototype.setupControlsWrapper = function () {\n        var usingWrapper = this.includeRowDrag || this.includeDndSource || this.includeSelection || this.forceWrapper;\n        var changed = true;\n        var notChanged = false;\n        this.addOrRemoveCssClass('ag-cell-value', !usingWrapper);\n        // turn wrapper on\n        if (usingWrapper && !this.eCellWrapper) {\n            this.addControlsWrapper();\n            return changed;\n        }\n        // turn wrapper off\n        if (!usingWrapper && this.eCellWrapper) {\n            this.removeControlsWrapper();\n            return changed;\n        }\n        return notChanged;\n    };\n    CellComp.prototype.addControlsWrapper = function () {\n        var eGui = this.getGui();\n        eGui.innerHTML = /* html */\n            \"<div ref=\\\"eCellWrapper\\\" class=\\\"ag-cell-wrapper\\\" role=\\\"presentation\\\">\\n                <span ref=\\\"eCellValue\\\" class=\\\"ag-cell-value\\\" role=\\\"presentation\\\"></span>\\n            </div>\";\n        this.eCellValue = this.getRefElement('eCellValue');\n        this.eCellWrapper = this.getRefElement('eCellWrapper');\n        if (!this.forceWrapper) {\n            this.eCellValue.setAttribute('unselectable', 'on');\n        }\n        var id = this.eCellValue.id = \"cell-\" + this.getCompId();\n        var describedByIds = [];\n        if (this.includeRowDrag) {\n            this.rowDraggingComp = this.cellCtrl.createRowDragComp();\n            if (this.rowDraggingComp) {\n                // put the checkbox in before the value\n                this.eCellWrapper.insertBefore(this.rowDraggingComp.getGui(), this.eCellValue);\n            }\n        }\n        if (this.includeDndSource) {\n            this.dndSourceComp = this.cellCtrl.createDndSource();\n            // put the checkbox in before the value\n            this.eCellWrapper.insertBefore(this.dndSourceComp.getGui(), this.eCellValue);\n        }\n        if (this.includeSelection) {\n            this.checkboxSelectionComp = this.cellCtrl.createSelectionCheckbox();\n            this.eCellWrapper.insertBefore(this.checkboxSelectionComp.getGui(), this.eCellValue);\n            describedByIds.push(this.checkboxSelectionComp.getCheckboxId());\n        }\n        describedByIds.push(id);\n        setAriaDescribedBy(this.getGui(), describedByIds.join(' '));\n    };\n    CellComp.prototype.createCellEditorInstance = function (compDetails, popup, position) {\n        var _this = this;\n        var versionCopy = this.editorVersion;\n        var cellEditorPromise = this.beans.userComponentFactory.createCellEditor(compDetails);\n        if (!cellEditorPromise) {\n            return;\n        } // if empty, userComponentFactory already did a console message\n        var params = compDetails.params;\n        cellEditorPromise.then(function (c) { return _this.afterCellEditorCreated(versionCopy, c, params, popup, position); });\n        // if we don't do this, and editor component is async, then there will be a period\n        // when the component isn't present and keyboard navigation won't work - so example\n        // of user hitting tab quickly (more quickly than renderers getting created) won't work\n        var cellEditorAsync = missing(this.cellEditor);\n        if (cellEditorAsync && params.cellStartedEdit) {\n            this.cellCtrl.focusCell(true);\n        }\n    };\n    CellComp.prototype.insertValueWithoutCellRenderer = function (valueToDisplay) {\n        var escapedValue = valueToDisplay != null ? escapeString(valueToDisplay) : null;\n        if (escapedValue != null) {\n            this.eCellValue.innerHTML = escapedValue;\n        }\n        else {\n            clearElement(this.eCellValue);\n        }\n    };\n    CellComp.prototype.insertValueUsingAngular1Template = function () {\n        var _this = this;\n        var _a = this.column.getColDef(), template = _a.template, templateUrl = _a.templateUrl;\n        var templateToInsert = undefined;\n        if (template != null) {\n            templateToInsert = template;\n        }\n        else if (templateUrl != null) {\n            // first time this happens it will return nothing, as the template will still be loading async,\n            // however once loaded it will refresh the cell and second time around it will be returned sync\n            // as in cache.\n            templateToInsert = this.beans.templateService.getTemplate(templateUrl, function () { return _this.cellCtrl.refreshCell({ forceRefresh: true }); });\n        }\n        else {\n            // should never happen, as we only enter this method when template or templateUrl exist\n        }\n        if (templateToInsert != null) {\n            this.eCellValue.innerHTML = templateToInsert;\n            this.updateAngular1ScopeAndCompile();\n        }\n    };\n    CellComp.prototype.destroyEditorAndRenderer = function () {\n        this.destroyRenderer();\n        this.destroyEditor();\n    };\n    CellComp.prototype.destroyRenderer = function () {\n        var context = this.beans.context;\n        this.cellRenderer = context.destroyBean(this.cellRenderer);\n        removeFromParent(this.cellRendererGui);\n        this.cellRendererGui = null;\n        this.rendererVersion++;\n    };\n    CellComp.prototype.destroyEditor = function () {\n        var context = this.beans.context;\n        if (this.hideEditorPopup) {\n            this.hideEditorPopup();\n        }\n        this.hideEditorPopup = undefined;\n        this.cellEditor = context.destroyBean(this.cellEditor);\n        this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);\n        removeFromParent(this.cellEditorGui);\n        this.cellEditorGui = null;\n        this.editorVersion++;\n    };\n    CellComp.prototype.refreshCellRenderer = function (compClassAndParams) {\n        if (this.cellRenderer == null || this.cellRenderer.refresh == null) {\n            return false;\n        }\n        // if different Cell Renderer configured this time (eg user is using selector, and\n        // returns different component) then don't refresh, force recreate of Cell Renderer\n        if (this.cellRendererClass !== compClassAndParams.componentClass) {\n            return false;\n        }\n        // take any custom params off of the user\n        var result = this.cellRenderer.refresh(compClassAndParams.params);\n        // NOTE on undefined: previous version of the cellRenderer.refresh() interface\n        // returned nothing, if the method existed, we assumed it refreshed. so for\n        // backwards compatibility, we assume if method exists and returns nothing,\n        // that it was successful.\n        return result === true || result === undefined;\n    };\n    CellComp.prototype.createCellRendererInstance = function (compClassAndParams) {\n        var _this = this;\n        // never use task service if angularCompileRows=true, as that assume the cell renderers\n        // are finished when the row is created. also we never use it if animation frame service\n        // is turned off.\n        // and lastly we never use it if doing auto-height, as the auto-height service checks the\n        // row height directly after the cell is created, it doesn't wait around for the tasks to complete\n        var angularCompileRows = this.beans.gridOptionsWrapper.isAngularCompileRows();\n        var suppressAnimationFrame = this.beans.gridOptionsWrapper.isSuppressAnimationFrame();\n        var useTaskService = !angularCompileRows && !suppressAnimationFrame && !this.autoHeightCell;\n        var displayComponentVersionCopy = this.rendererVersion;\n        var componentClass = compClassAndParams.componentClass;\n        var createCellRendererFunc = function () {\n            var staleTask = _this.rendererVersion !== displayComponentVersionCopy || !_this.isAlive();\n            if (staleTask) {\n                return;\n            }\n            // this can return null in the event that the user has switched from a renderer component to nothing, for example\n            // when using a cellRendererSelect to return a component or null depending on row data etc\n            var componentPromise = _this.beans.userComponentFactory.createCellRenderer(compClassAndParams);\n            var callback = _this.afterCellRendererCreated.bind(_this, displayComponentVersionCopy, componentClass);\n            if (componentPromise) {\n                componentPromise.then(callback);\n            }\n        };\n        // we only use task service when rendering for first time, which means it is not used when doing edits.\n        // if we changed this (always use task service) would make sense, however it would break tests, possibly\n        // test of users.\n        if (useTaskService && this.firstRender) {\n            this.beans.taskQueue.createTask(createCellRendererFunc, this.rowNode.rowIndex, 'createTasksP2');\n        }\n        else {\n            createCellRendererFunc();\n        }\n    };\n    CellComp.prototype.isUsingAngular1Template = function () {\n        var colDef = this.column.getColDef();\n        var res = colDef.template != null || colDef.templateUrl != null;\n        return res;\n    };\n    CellComp.prototype.getCtrl = function () {\n        return this.cellCtrl;\n    };\n    CellComp.prototype.getRowCtrl = function () {\n        return this.rowCtrl;\n    };\n    CellComp.prototype.getCellRenderer = function () {\n        return this.cellRenderer;\n    };\n    CellComp.prototype.getCellEditor = function () {\n        return this.cellEditor;\n    };\n    CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRendererClass, cellRenderer) {\n        var staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;\n        if (staleTask) {\n            this.beans.context.destroyBean(cellRenderer);\n            return;\n        }\n        this.cellRenderer = cellRenderer;\n        this.cellRendererClass = cellRendererClass;\n        this.cellRendererGui = this.cellRenderer.getGui();\n        if (this.cellRendererGui != null) {\n            clearElement(this.eCellValue);\n            this.eCellValue.appendChild(this.cellRendererGui);\n            this.updateAngular1ScopeAndCompile();\n        }\n    };\n    CellComp.prototype.afterCellEditorCreated = function (requestVersion, cellEditor, params, popup, position) {\n        // if editingCell=false, means user cancelled the editor before component was ready.\n        // if versionMismatch, then user cancelled the edit, then started the edit again, and this\n        //   is the first editor which is now stale.\n        var staleComp = requestVersion !== this.editorVersion;\n        if (staleComp) {\n            this.beans.context.destroyBean(cellEditor);\n            return;\n        }\n        var editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();\n        if (editingCancelledByUserComp) {\n            this.beans.context.destroyBean(cellEditor);\n            this.cellCtrl.stopEditing();\n            return;\n        }\n        if (!cellEditor.getGui) {\n            console.warn(\"AG Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\");\n            this.beans.context.destroyBean(cellEditor);\n            return;\n        }\n        this.cellEditor = cellEditor;\n        this.cellEditorGui = cellEditor.getGui();\n        var cellEditorInPopup = popup || (cellEditor.isPopup !== undefined && cellEditor.isPopup());\n        if (cellEditorInPopup) {\n            if (!popup) {\n                this.cellCtrl.hackSayEditingInPopup();\n            }\n            this.addPopupCellEditor(params, position);\n        }\n        else {\n            this.addInCellEditor();\n        }\n        if (cellEditor.afterGuiAttached) {\n            cellEditor.afterGuiAttached();\n        }\n    };\n    CellComp.prototype.addInCellEditor = function () {\n        var eGui = this.getGui();\n        // if focus is inside the cell, we move focus to the cell itself\n        // before removing it's contents, otherwise errors could be thrown.\n        if (eGui.contains(document.activeElement)) {\n            eGui.focus();\n        }\n        this.destroyRenderer();\n        this.removeControlsWrapper();\n        this.clearCellElement();\n        if (this.cellEditorGui) {\n            eGui.appendChild(this.cellEditorGui);\n        }\n    };\n    CellComp.prototype.addPopupCellEditor = function (params, position) {\n        var _this = this;\n        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n            console.warn('AG Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' +\n                '- either turn off fullRowEdit, or stop using popup editors.');\n        }\n        var cellEditor = this.cellEditor;\n        // if a popup, then we wrap in a popup editor and return the popup\n        this.cellEditorPopupWrapper = this.beans.context.createBean(new PopupEditorWrapper(params));\n        var ePopupGui = this.cellEditorPopupWrapper.getGui();\n        if (this.cellEditorGui) {\n            ePopupGui.appendChild(this.cellEditorGui);\n        }\n        var popupService = this.beans.popupService;\n        var useModelPopup = this.beans.gridOptionsWrapper.isStopEditingWhenCellsLoseFocus();\n        // see if position provided by colDef, if not then check old way of method on cellComp\n        var positionToUse = position != null ? position : cellEditor.getPopupPosition ? cellEditor.getPopupPosition() : 'over';\n        var positionParams = {\n            column: this.column,\n            rowNode: this.rowNode,\n            type: 'popupCellEditor',\n            eventSource: this.getGui(),\n            ePopup: ePopupGui,\n            keepWithinBounds: true\n        };\n        var positionCallback = position === 'under' ?\n            popupService.positionPopupUnderComponent.bind(popupService, positionParams)\n            : popupService.positionPopupOverComponent.bind(popupService, positionParams);\n        var addPopupRes = popupService.addPopup({\n            modal: useModelPopup,\n            eChild: ePopupGui,\n            closeOnEsc: true,\n            closedCallback: function () { _this.cellCtrl.onPopupEditorClosed(); },\n            anchorToElement: this.getGui(),\n            positionCallback: positionCallback\n        });\n        if (addPopupRes) {\n            this.hideEditorPopup = addPopupRes.hideFunc;\n        }\n    };\n    CellComp.prototype.detach = function () {\n        this.eRow.removeChild(this.getGui());\n    };\n    // if the row is also getting destroyed, then we don't need to remove from dom,\n    // as the row will also get removed, so no need to take out the cells from the row\n    // if the row is going (removing is an expensive operation, so only need to remove\n    // the top part)\n    //\n    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.\n    CellComp.prototype.destroy = function () {\n        this.cellCtrl.stopEditing();\n        this.destroyEditorAndRenderer();\n        this.removeControlsWrapper();\n        if (this.angularCompiledElement) {\n            this.angularCompiledElement.remove();\n            this.angularCompiledElement = undefined;\n        }\n        _super.prototype.destroy.call(this);\n    };\n    CellComp.prototype.clearCellElement = function () {\n        var eGui = this.getGui();\n        // if focus is inside the cell, we move focus to the cell itself\n        // before removing it's contents, otherwise errors could be thrown.\n        if (eGui.contains(document.activeElement) && !isBrowserIE()) {\n            eGui.focus({\n                preventScroll: true\n            });\n        }\n        clearElement(eGui);\n    };\n    CellComp.prototype.updateAngular1ScopeAndCompile = function () {\n        if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {\n            this.scope.data = __assign({}, this.rowNode.data);\n            if (this.angularCompiledElement) {\n                this.angularCompiledElement.remove();\n            }\n            this.angularCompiledElement = this.beans.$compile(this.eCellValue.children)(this.scope);\n            // because this.scope is set, we are guaranteed GridBodyComp is vanilla JS, ie it's GridBodyComp.ts from AG Stack and and not react\n            this.beans.ctrlsService.getGridBodyCtrl().requestAngularApply();\n        }\n    };\n    return CellComp;\n}(Component));\nexport { CellComp };\n"]},"metadata":{},"sourceType":"module"}