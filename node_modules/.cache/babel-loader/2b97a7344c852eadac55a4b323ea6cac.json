{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { _, Autowired, Bean, BeanStub, ChangedPath, Constants, Events, GridOptionsWrapper, Optional, PostConstruct, ClientSideRowModelSteps, RowNode, RowHighlightPosition } from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager\";\nvar RecursionType;\n\n(function (RecursionType) {\n  RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n  RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n  RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n  RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n})(RecursionType || (RecursionType = {}));\n\nvar ClientSideRowModel = function (_super) {\n  __extends(ClientSideRowModel, _super);\n\n  function ClientSideRowModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ClientSideRowModel.prototype.init = function () {\n    var refreshEverythingFunc = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.EVERYTHING\n    });\n    var refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.EVERYTHING,\n      afterColumnsChanged: true,\n      keepRenderedRows: true,\n      animate: true\n    });\n    this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.PIVOT\n    }));\n    this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n    var refreshMapListener = this.refreshModel.bind(this, {\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      animate: true\n    });\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapListener);\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapListener);\n    this.rootNode = new RowNode();\n    this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsWrapper, this.getContext(), this.eventService, this.columnModel, this.gridApi, this.columnApi, this.selectionService);\n    this.createBean(this.rootNode);\n  };\n\n  ClientSideRowModel.prototype.start = function () {\n    var rowData = this.gridOptionsWrapper.getRowData();\n\n    if (rowData) {\n      this.setRowData(rowData);\n    }\n  };\n\n  ClientSideRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) {\n    var atLeastOneChange;\n    var res = false; // we do this multiple times as changing the row heights can also change the first and last rows,\n    // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n    // more rows.\n\n    do {\n      atLeastOneChange = false;\n      var rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n      var rowAtEndPixel = this.getRowIndexAtPixel(endPixel); // keep check to current page if doing pagination\n\n      var firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n      var lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n\n      for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n        var rowNode = this.getRow(rowIndex);\n\n        if (rowNode.rowHeightEstimated) {\n          var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);\n          rowNode.setRowHeight(rowHeight.height);\n          atLeastOneChange = true;\n          res = true;\n        }\n      }\n\n      if (atLeastOneChange) {\n        this.setRowTopAndRowIndex();\n      }\n    } while (atLeastOneChange);\n\n    return res;\n  };\n\n  ClientSideRowModel.prototype.setRowTopAndRowIndex = function () {\n    var nextRowTop = 0;\n\n    for (var i = 0; i < this.rowsToDisplay.length; i++) {\n      // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n      // with these two layouts.\n      var allowEstimate = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n      var rowNode = this.rowsToDisplay[i];\n\n      if (_.missing(rowNode.rowHeight)) {\n        var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode, allowEstimate);\n        rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n      }\n\n      rowNode.setRowTop(nextRowTop);\n      rowNode.setRowIndex(i);\n      nextRowTop += rowNode.rowHeight;\n    }\n  };\n\n  ClientSideRowModel.prototype.clearRowTopAndRowIndex = function (changedPath) {\n    var displayedRowsMapped = {};\n    this.rowsToDisplay.forEach(function (rowNode) {\n      if (rowNode.id != null) {\n        displayedRowsMapped[rowNode.id] = rowNode;\n      }\n    });\n\n    var clearIfNotDisplayed = function (rowNode) {\n      if (rowNode && rowNode.id != null && displayedRowsMapped[rowNode.id] == null) {\n        rowNode.clearRowTopAndRowIndex();\n      }\n    };\n\n    var recurse = function (rowNode) {\n      clearIfNotDisplayed(rowNode);\n      clearIfNotDisplayed(rowNode.detailNode);\n      clearIfNotDisplayed(rowNode.sibling);\n\n      if (rowNode.hasChildren()) {\n        if (rowNode.childrenAfterGroup) {\n          // if a changedPath is active, it means we are here because of a transaction update or\n          // a change detection. neither of these impacts the open/closed state of groups. so if\n          // a group is not open this time, it was not open last time. so we know all closed groups\n          // already have their top positions cleared. so there is no need to traverse all the way\n          // when changedPath is active and the rowNode is not expanded.\n          var isRootNode = rowNode.level == -1; // we need to give special consideration for root node,\n          // as expanded=undefined for root node\n\n          var skipChildren = changedPath.isActive() && !isRootNode && !rowNode.expanded;\n\n          if (!skipChildren) {\n            rowNode.childrenAfterGroup.forEach(recurse);\n          }\n        }\n      }\n    };\n\n    recurse(this.rootNode);\n  }; // returns false if row was moved, otherwise true\n\n\n  ClientSideRowModel.prototype.ensureRowsAtPixel = function (rowNodes, pixel, increment) {\n    var _this = this;\n\n    if (increment === void 0) {\n      increment = 0;\n    }\n\n    var indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n    var rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n\n    if (rowNodeAtPixelNow === rowNodes[0]) {\n      return false;\n    }\n\n    rowNodes.forEach(function (rowNode) {\n      _.removeFromArray(_this.rootNode.allLeafChildren, rowNode);\n    });\n    rowNodes.forEach(function (rowNode, idx) {\n      _.insertIntoArray(_this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n    });\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      keepRenderedRows: true,\n      animate: true,\n      keepEditingRows: true\n    });\n    return true;\n  };\n\n  ClientSideRowModel.prototype.highlightRowAtPixel = function (rowNode, pixel) {\n    var indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n    var rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n\n    if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n      if (this.lastHighlightedRow) {\n        this.lastHighlightedRow.setHighlighted(null);\n        this.lastHighlightedRow = null;\n      }\n\n      return;\n    }\n\n    var highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n\n    if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n      this.lastHighlightedRow.setHighlighted(null);\n      this.lastHighlightedRow = null;\n    }\n\n    rowNodeAtPixelNow.setHighlighted(highlight);\n    this.lastHighlightedRow = rowNodeAtPixelNow;\n  };\n\n  ClientSideRowModel.prototype.getHighlightPosition = function (pixel, rowNode) {\n    if (!rowNode) {\n      var index = this.getRowIndexAtPixel(pixel);\n      rowNode = this.getRow(index || 0);\n\n      if (!rowNode) {\n        return RowHighlightPosition.Below;\n      }\n    }\n\n    var rowTop = rowNode.rowTop,\n        rowHeight = rowNode.rowHeight;\n    return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n  };\n\n  ClientSideRowModel.prototype.getLastHighlightedRowNode = function () {\n    return this.lastHighlightedRow;\n  };\n\n  ClientSideRowModel.prototype.isLastRowIndexKnown = function () {\n    return true;\n  };\n\n  ClientSideRowModel.prototype.getRowCount = function () {\n    if (this.rowsToDisplay) {\n      return this.rowsToDisplay.length;\n    }\n\n    return 0;\n  };\n\n  ClientSideRowModel.prototype.getTopLevelRowCount = function () {\n    var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n    if (showingRootNode) {\n      return 1;\n    }\n\n    return this.rootNode.childrenAfterFilter ? this.rootNode.childrenAfterFilter.length : 0;\n  };\n\n  ClientSideRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n    var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n    if (showingRootNode) {\n      return topLevelIndex;\n    }\n\n    var rowNode = this.rootNode.childrenAfterSort[topLevelIndex];\n\n    if (this.gridOptionsWrapper.isGroupHideOpenParents()) {\n      // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n      while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n        rowNode = rowNode.childrenAfterSort[0];\n      }\n    }\n\n    return rowNode.rowIndex;\n  };\n\n  ClientSideRowModel.prototype.getRowBounds = function (index) {\n    if (_.missing(this.rowsToDisplay)) {\n      return null;\n    }\n\n    var rowNode = this.rowsToDisplay[index];\n\n    if (rowNode) {\n      return {\n        rowTop: rowNode.rowTop,\n        rowHeight: rowNode.rowHeight\n      };\n    }\n\n    return null;\n  };\n\n  ClientSideRowModel.prototype.onRowGroupOpened = function () {\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      animate: animate\n    });\n  };\n\n  ClientSideRowModel.prototype.onFilterChanged = function (event) {\n    if (event.afterDataChange) {\n      return;\n    }\n\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: ClientSideRowModelSteps.FILTER,\n      keepRenderedRows: true,\n      animate: animate\n    });\n  };\n\n  ClientSideRowModel.prototype.onSortChanged = function () {\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: ClientSideRowModelSteps.SORT,\n      keepRenderedRows: true,\n      animate: animate,\n      keepEditingRows: true\n    });\n  };\n\n  ClientSideRowModel.prototype.getType = function () {\n    return Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n  };\n\n  ClientSideRowModel.prototype.onValueChanged = function () {\n    if (this.columnModel.isPivotActive()) {\n      this.refreshModel({\n        step: ClientSideRowModelSteps.PIVOT\n      });\n    } else {\n      this.refreshModel({\n        step: ClientSideRowModelSteps.AGGREGATE\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.createChangePath = function (rowNodeTransactions) {\n    // for updates, if the row is updated at all, then we re-calc all the values\n    // in that row. we could compare each value to each old value, however if we\n    // did this, we would be calling the valueService twice, once on the old value\n    // and once on the new value. so it's less valueGetter calls if we just assume\n    // each column is different. that way the changedPath is used so that only\n    // the impacted parent rows are recalculated, parents who's children have\n    // not changed are not impacted.\n    var noTransactions = _.missingOrEmpty(rowNodeTransactions);\n\n    var changedPath = new ChangedPath(false, this.rootNode);\n\n    if (noTransactions || this.gridOptionsWrapper.isTreeData()) {\n      changedPath.setInactive();\n    }\n\n    return changedPath;\n  };\n\n  ClientSideRowModel.prototype.isSuppressModelUpdateAfterUpdateTransaction = function (params) {\n    if (!this.gridOptionsWrapper.isSuppressModelUpdateAfterUpdateTransaction()) {\n      return false;\n    } // return true if we are only doing update transactions\n\n\n    if (params.rowNodeTransactions == null) {\n      return false;\n    }\n\n    var transWithAddsOrDeletes = _.filter(params.rowNodeTransactions, function (tx) {\n      return tx.add != null && tx.add.length > 0 || tx.remove != null && tx.remove.length > 0;\n    });\n\n    var transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n    return transactionsContainUpdatesOnly;\n  };\n\n  ClientSideRowModel.prototype.refreshModel = function (params) {\n    var _this = this;\n\n    if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n      return;\n    } // this goes through the pipeline of stages. what's in my head is similar\n    // to the diagram on this page:\n    // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n    // however we want to keep the results of each stage, hence we manually call\n    // each step rather than have them chain each other.\n    // fallthrough in below switch is on purpose,\n    // eg if STEP_FILTER, then all steps below this\n    // step get done\n    // let start: number;\n    // console.log('======= start =======');\n\n\n    var changedPath = this.createChangePath(params.rowNodeTransactions);\n\n    switch (params.step) {\n      case ClientSideRowModelSteps.EVERYTHING:\n        this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, !!params.afterColumnsChanged);\n\n      case ClientSideRowModelSteps.FILTER:\n        this.doFilter(changedPath);\n\n      case ClientSideRowModelSteps.PIVOT:\n        this.doPivot(changedPath);\n\n      case ClientSideRowModelSteps.AGGREGATE:\n        // depends on agg fields\n        this.doAggregate(changedPath);\n\n      case ClientSideRowModelSteps.SORT:\n        this.doSort(params.rowNodeTransactions, changedPath);\n\n      case ClientSideRowModelSteps.MAP:\n        this.doRowsToDisplay();\n    } // set all row tops to null, then set row tops on all visible rows. if we don't\n    // do this, then the algorithm below only sets row tops, old row tops from old rows\n    // will still lie around\n\n\n    this.setRowTopAndRowIndex();\n    this.clearRowTopAndRowIndex(changedPath);\n    var event = {\n      type: Events.EVENT_MODEL_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      animate: params.animate,\n      keepRenderedRows: params.keepRenderedRows,\n      newData: params.newData,\n      newPage: false\n    };\n    this.eventService.dispatchEvent(event);\n\n    if (this.$scope) {\n      window.setTimeout(function () {\n        _this.$scope.$apply();\n      }, 0);\n    }\n  };\n\n  ClientSideRowModel.prototype.isEmpty = function () {\n    var rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n    return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n  };\n\n  ClientSideRowModel.prototype.isRowsToRender = function () {\n    return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n  };\n\n  ClientSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n    // if lastSelectedNode is missing, we start at the first row\n    var firstRowHit = !lastInRange;\n    var lastRowHit = false;\n    var lastRow;\n    var result = [];\n    var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n    this.forEachNodeAfterFilterAndSort(function (rowNode) {\n      var lookingForLastRow = firstRowHit && !lastRowHit; // check if we need to flip the select switch\n\n      if (!firstRowHit) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          firstRowHit = true;\n        }\n      }\n\n      var skipThisGroupNode = rowNode.group && groupsSelectChildren;\n\n      if (!skipThisGroupNode) {\n        var inRange = firstRowHit && !lastRowHit;\n        var childOfLastRow = rowNode.isParentOfNode(lastRow);\n\n        if (inRange || childOfLastRow) {\n          result.push(rowNode);\n        }\n      }\n\n      if (lookingForLastRow) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          lastRowHit = true;\n\n          if (rowNode === lastInRange) {\n            lastRow = lastInRange;\n          } else {\n            lastRow = firstInRange;\n          }\n        }\n      }\n    });\n    return result;\n  };\n\n  ClientSideRowModel.prototype.setDatasource = function (datasource) {\n    console.error('AG Grid: should never call setDatasource on clientSideRowController');\n  };\n\n  ClientSideRowModel.prototype.getTopLevelNodes = function () {\n    return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n  };\n\n  ClientSideRowModel.prototype.getRootNode = function () {\n    return this.rootNode;\n  };\n\n  ClientSideRowModel.prototype.getRow = function (index) {\n    return this.rowsToDisplay[index];\n  };\n\n  ClientSideRowModel.prototype.isRowPresent = function (rowNode) {\n    return this.rowsToDisplay.indexOf(rowNode) >= 0;\n  };\n\n  ClientSideRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {\n    if (this.isEmpty()) {\n      return -1;\n    } // do binary search of tree\n    // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n\n\n    var bottomPointer = 0;\n    var topPointer = this.rowsToDisplay.length - 1; // quick check, if the pixel is out of bounds, then return last row\n\n    if (pixelToMatch <= 0) {\n      // if pixel is less than or equal zero, it's always the first row\n      return 0;\n    }\n\n    var lastNode = _.last(this.rowsToDisplay);\n\n    if (lastNode.rowTop <= pixelToMatch) {\n      return this.rowsToDisplay.length - 1;\n    }\n\n    while (true) {\n      var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n      var currentRowNode = this.rowsToDisplay[midPointer];\n\n      if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n        return midPointer;\n      }\n\n      if (currentRowNode.rowTop < pixelToMatch) {\n        bottomPointer = midPointer + 1;\n      } else if (currentRowNode.rowTop > pixelToMatch) {\n        topPointer = midPointer - 1;\n      }\n    }\n  };\n\n  ClientSideRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {\n    var topPixel = rowNode.rowTop;\n    var bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n    var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n    return pixelInRow;\n  };\n\n  ClientSideRowModel.prototype.forEachLeafNode = function (callback) {\n    if (this.rootNode.allLeafChildren) {\n      this.rootNode.allLeafChildren.forEach(function (rowNode, index) {\n        return callback(rowNode, index);\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.forEachNode = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachNodeAfterFilter = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachPivotNode = function (callback) {\n    this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);\n  }; // iterates through each item in memory, and calls the callback function\n  // nodes - the rowNodes to traverse\n  // callback - the user provided callback\n  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n  // index - works similar to the index in forEach in javascript's array function\n\n\n  ClientSideRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {\n    if (!nodes) {\n      return index;\n    }\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      callback(node, index++); // go to the next level if it is a group\n\n      if (node.hasChildren()) {\n        // depending on the recursion type, we pick a difference set of children\n        var nodeChildren = null;\n\n        switch (recursionType) {\n          case RecursionType.Normal:\n            nodeChildren = node.childrenAfterGroup;\n            break;\n\n          case RecursionType.AfterFilter:\n            nodeChildren = node.childrenAfterFilter;\n            break;\n\n          case RecursionType.AfterFilterAndSort:\n            nodeChildren = node.childrenAfterSort;\n            break;\n\n          case RecursionType.PivotNodes:\n            // for pivot, we don't go below leafGroup levels\n            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n            break;\n        }\n\n        if (nodeChildren) {\n          index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);\n        }\n      }\n    }\n\n    return index;\n  }; // it's possible to recompute the aggregate without doing the other parts\n  // + gridApi.recomputeAggregates()\n\n\n  ClientSideRowModel.prototype.doAggregate = function (changedPath) {\n    if (this.aggregationStage) {\n      this.aggregationStage.execute({\n        rowNode: this.rootNode,\n        changedPath: changedPath\n      });\n    }\n  }; // + gridApi.expandAll()\n  // + gridApi.collapseAll()\n\n\n  ClientSideRowModel.prototype.expandOrCollapseAll = function (expand) {\n    var usingTreeData = this.gridOptionsWrapper.isTreeData();\n\n    if (this.rootNode) {\n      recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n    }\n\n    function recursiveExpandOrCollapse(rowNodes) {\n      if (!rowNodes) {\n        return;\n      }\n\n      rowNodes.forEach(function (rowNode) {\n        var shouldExpandOrCollapse = usingTreeData ? _.exists(rowNode.childrenAfterGroup) : rowNode.group;\n\n        if (shouldExpandOrCollapse) {\n          rowNode.expanded = expand;\n          recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n        }\n      });\n    }\n\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP\n    });\n    var eventSource = expand ? 'expandAll' : 'collapseAll';\n    var event = {\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n      source: eventSource\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ClientSideRowModel.prototype.doSort = function (rowNodeTransactions, changedPath) {\n    this.sortStage.execute({\n      rowNode: this.rootNode,\n      rowNodeTransactions: rowNodeTransactions,\n      changedPath: changedPath\n    });\n  };\n\n  ClientSideRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {\n    if (this.groupStage) {\n      if (rowNodeTransactions) {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          rowNodeTransactions: rowNodeTransactions,\n          rowNodeOrder: rowNodeOrder,\n          changedPath: changedPath\n        });\n      } else {\n        // groups are about to get disposed, so need to deselect any that are selected\n        this.selectionService.removeGroupsFromSelection();\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          changedPath: changedPath,\n          afterColumnsChanged: afterColumnsChanged\n        }); // set open/closed state on groups\n\n        this.restoreGroupState(groupState);\n      }\n\n      if (this.gridOptionsWrapper.isGroupSelectsChildren()) {\n        this.selectionService.updateGroupsFromChildrenSelections(changedPath);\n      }\n    } else {\n      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n      this.rootNode.updateHasChildren();\n    }\n  };\n\n  ClientSideRowModel.prototype.restoreGroupState = function (groupState) {\n    if (!groupState) {\n      return;\n    }\n\n    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n      // if the group was open last time, then open it this time. however\n      // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n      // setting will take effect.\n      if (typeof groupState[key] === 'boolean') {\n        node.expanded = groupState[key];\n      }\n    });\n  };\n\n  ClientSideRowModel.prototype.doFilter = function (changedPath) {\n    this.filterStage.execute({\n      rowNode: this.rootNode,\n      changedPath: changedPath\n    });\n  };\n\n  ClientSideRowModel.prototype.doPivot = function (changedPath) {\n    if (this.pivotStage) {\n      this.pivotStage.execute({\n        rowNode: this.rootNode,\n        changedPath: changedPath\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.getGroupState = function () {\n    if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {\n      return null;\n    }\n\n    var result = {};\n\n    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n      return result[key] = node.expanded;\n    });\n\n    return result;\n  };\n\n  ClientSideRowModel.prototype.getCopyOfNodesMap = function () {\n    return this.nodeManager.getCopyOfNodesMap();\n  };\n\n  ClientSideRowModel.prototype.getRowNode = function (id) {\n    // although id is typed a string, this could be called by the user, and they could have passed a number\n    var idIsGroup = typeof id == 'string' && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;\n\n    if (idIsGroup) {\n      // only one users complained about getRowNode not working for groups, after years of\n      // this working for normal rows. so have done quick implementation. if users complain\n      // about performance, then GroupStage should store / manage created groups in a map,\n      // which is a chunk of work.\n      var res_1 = undefined;\n      this.forEachNode(function (node) {\n        if (node.id === id) {\n          res_1 = node;\n        }\n      });\n      return res_1;\n    } else {\n      return this.nodeManager.getRowNode(id);\n    }\n  }; // rows: the rows to put into the model\n\n\n  ClientSideRowModel.prototype.setRowData = function (rowData) {\n    // no need to invalidate cache, as the cache is stored on the rowNode,\n    // so new rowNodes means the cache is wiped anyway.\n    // remember group state, so we can expand groups that should be expanded\n    var groupState = this.getGroupState();\n    this.nodeManager.setRowData(rowData); // this event kicks off:\n    // - clears selection\n    // - updates filters\n    // - shows 'no rows' overlay if needed\n\n    var rowDataChangedEvent = {\n      type: Events.EVENT_ROW_DATA_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(rowDataChangedEvent);\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      groupState: groupState,\n      newData: true\n    });\n  };\n\n  ClientSideRowModel.prototype.batchUpdateRowData = function (rowDataTransaction, callback) {\n    var _this = this;\n\n    if (this.applyAsyncTransactionsTimeout == null) {\n      this.rowDataTransactionBatch = [];\n      var waitMillis = this.gridOptionsWrapper.getAsyncTransactionWaitMillis();\n      this.applyAsyncTransactionsTimeout = window.setTimeout(function () {\n        _this.executeBatchUpdateRowData();\n      }, waitMillis);\n    }\n\n    this.rowDataTransactionBatch.push({\n      rowDataTransaction: rowDataTransaction,\n      callback: callback\n    });\n  };\n\n  ClientSideRowModel.prototype.flushAsyncTransactions = function () {\n    if (this.applyAsyncTransactionsTimeout != null) {\n      clearTimeout(this.applyAsyncTransactionsTimeout);\n      this.executeBatchUpdateRowData();\n    }\n  };\n\n  ClientSideRowModel.prototype.executeBatchUpdateRowData = function () {\n    var _this = this;\n\n    this.valueCache.onDataChanged();\n    var callbackFuncsBound = [];\n    var rowNodeTrans = []; // The rowGroup stage uses rowNodeOrder if order was provided. if we didn't pass 'true' to\n    // commonUpdateRowData, using addIndex would have no effect when grouping.\n\n    var forceRowNodeOrder = false;\n\n    if (this.rowDataTransactionBatch) {\n      this.rowDataTransactionBatch.forEach(function (tranItem) {\n        var rowNodeTran = _this.nodeManager.updateRowData(tranItem.rowDataTransaction, undefined);\n\n        rowNodeTrans.push(rowNodeTran);\n\n        if (tranItem.callback) {\n          callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n        }\n\n        if (typeof tranItem.rowDataTransaction.addIndex === 'number') {\n          forceRowNodeOrder = true;\n        }\n      });\n    }\n\n    this.commonUpdateRowData(rowNodeTrans, undefined, forceRowNodeOrder); // do callbacks in next VM turn so it's async\n\n    if (callbackFuncsBound.length > 0) {\n      window.setTimeout(function () {\n        callbackFuncsBound.forEach(function (func) {\n          return func();\n        });\n      }, 0);\n    }\n\n    if (rowNodeTrans.length > 0) {\n      var event_1 = {\n        api: this.gridOptionsWrapper.getApi(),\n        columnApi: this.gridOptionsWrapper.getColumnApi(),\n        type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n        results: rowNodeTrans\n      };\n      this.eventService.dispatchEvent(event_1);\n    }\n\n    this.rowDataTransactionBatch = null;\n    this.applyAsyncTransactionsTimeout = undefined;\n  };\n\n  ClientSideRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n    this.valueCache.onDataChanged();\n    var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder); // if doing immutableData, addIndex is never present. however if doing standard transaction, and user\n    // provided addIndex, then this is used in updateRowData. However if doing Enterprise, then the rowGroup\n    // stage also uses the\n\n    var forceRowNodeOrder = typeof rowDataTran.addIndex === 'number';\n    this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);\n    return rowNodeTran;\n  };\n\n  ClientSideRowModel.prototype.createRowNodeOrder = function () {\n    var suppressSortOrder = this.gridOptionsWrapper.isSuppressMaintainUnsortedOrder();\n\n    if (suppressSortOrder) {\n      return;\n    }\n\n    var orderMap = {};\n\n    if (this.rootNode && this.rootNode.allLeafChildren) {\n      for (var index = 0; index < this.rootNode.allLeafChildren.length; index++) {\n        var node = this.rootNode.allLeafChildren[index];\n        orderMap[node.id] = index;\n      }\n    }\n\n    return orderMap;\n  }; // common to updateRowData and batchUpdateRowData\n\n\n  ClientSideRowModel.prototype.commonUpdateRowData = function (rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {\n    if (forceRowNodeOrder) {\n      rowNodeOrder = this.createRowNodeOrder();\n    }\n\n    this.refreshModel({\n      step: ClientSideRowModelSteps.EVERYTHING,\n      rowNodeTransactions: rowNodeTrans,\n      rowNodeOrder: rowNodeOrder,\n      keepRenderedRows: true,\n      animate: true,\n      keepEditingRows: true\n    });\n    var event = {\n      type: Events.EVENT_ROW_DATA_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ClientSideRowModel.prototype.doRowsToDisplay = function () {\n    this.rowsToDisplay = this.flattenStage.execute({\n      rowNode: this.rootNode\n    });\n  };\n\n  ClientSideRowModel.prototype.onRowHeightChanged = function () {\n    this.refreshModel({\n      step: ClientSideRowModelSteps.MAP,\n      keepRenderedRows: true,\n      keepEditingRows: true\n    });\n  };\n\n  ClientSideRowModel.prototype.resetRowHeights = function () {\n    var atLeastOne = false;\n    this.forEachNode(function (rowNode) {\n      rowNode.setRowHeight(rowNode.rowHeight, true); // we keep the height each row is at, however we set estimated=true rather than clear the height.\n      // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n      // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n\n      var detailNode = rowNode.detailNode;\n\n      if (detailNode) {\n        detailNode.setRowHeight(detailNode.rowHeight, true);\n      }\n\n      atLeastOne = true;\n    });\n\n    if (atLeastOne) {\n      this.onRowHeightChanged();\n    }\n  };\n\n  __decorate([Autowired('columnModel')], ClientSideRowModel.prototype, \"columnModel\", void 0);\n\n  __decorate([Autowired('$scope')], ClientSideRowModel.prototype, \"$scope\", void 0);\n\n  __decorate([Autowired('selectionService')], ClientSideRowModel.prototype, \"selectionService\", void 0);\n\n  __decorate([Autowired('valueCache')], ClientSideRowModel.prototype, \"valueCache\", void 0);\n\n  __decorate([Autowired('columnApi')], ClientSideRowModel.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], ClientSideRowModel.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired('animationFrameService')], ClientSideRowModel.prototype, \"animationFrameService\", void 0);\n\n  __decorate([Autowired('filterStage')], ClientSideRowModel.prototype, \"filterStage\", void 0);\n\n  __decorate([Autowired('sortStage')], ClientSideRowModel.prototype, \"sortStage\", void 0);\n\n  __decorate([Autowired('flattenStage')], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n\n  __decorate([Optional('groupStage')], ClientSideRowModel.prototype, \"groupStage\", void 0);\n\n  __decorate([Optional('aggregationStage')], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n\n  __decorate([Optional('pivotStage')], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n\n  __decorate([PostConstruct], ClientSideRowModel.prototype, \"init\", null);\n\n  ClientSideRowModel = __decorate([Bean('rowModel')], ClientSideRowModel);\n  return ClientSideRowModel;\n}(BeanStub);\n\nexport { ClientSideRowModel };","map":{"version":3,"sources":["/Users/mphelps/react-app/TasQDashboard-main/node_modules/@ag-grid-community/client-side-row-model/dist/es6/clientSideRowModel/clientSideRowModel.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","_","Autowired","Bean","BeanStub","ChangedPath","Constants","Events","GridOptionsWrapper","Optional","PostConstruct","ClientSideRowModelSteps","RowNode","RowHighlightPosition","ClientSideNodeManager","RecursionType","ClientSideRowModel","_super","apply","init","refreshEverythingFunc","refreshModel","bind","step","EVERYTHING","refreshEverythingAfterColsChangedFunc","afterColumnsChanged","keepRenderedRows","animate","addManagedListener","eventService","EVENT_NEW_COLUMNS_LOADED","EVENT_COLUMN_ROW_GROUP_CHANGED","EVENT_COLUMN_VALUE_CHANGED","onValueChanged","EVENT_COLUMN_PIVOT_CHANGED","PIVOT","EVENT_FILTER_CHANGED","onFilterChanged","EVENT_SORT_CHANGED","onSortChanged","EVENT_COLUMN_PIVOT_MODE_CHANGED","refreshMapListener","MAP","gridOptionsWrapper","PROP_GROUP_REMOVE_SINGLE_CHILDREN","PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN","rootNode","nodeManager","getContext","columnModel","gridApi","columnApi","selectionService","createBean","start","rowData","getRowData","setRowData","ensureRowHeightsValid","startPixel","endPixel","startLimitIndex","endLimitIndex","atLeastOneChange","res","rowAtStartPixel","getRowIndexAtPixel","rowAtEndPixel","firstRow","Math","max","lastRow","min","rowIndex","rowNode","getRow","rowHeightEstimated","rowHeight","getRowHeightForNode","setRowHeight","height","setRowTopAndRowIndex","nextRowTop","rowsToDisplay","allowEstimate","getDomLayout","DOM_LAYOUT_NORMAL","missing","estimated","setRowTop","setRowIndex","clearRowTopAndRowIndex","changedPath","displayedRowsMapped","forEach","id","clearIfNotDisplayed","recurse","detailNode","sibling","hasChildren","childrenAfterGroup","isRootNode","level","skipChildren","isActive","expanded","ensureRowsAtPixel","rowNodes","pixel","increment","_this","indexAtPixelNow","rowNodeAtPixelNow","removeFromArray","allLeafChildren","idx","insertIntoArray","keepEditingRows","highlightRowAtPixel","lastHighlightedRow","setHighlighted","highlight","getHighlightPosition","index","Below","rowTop","Above","getLastHighlightedRowNode","isLastRowIndexKnown","getRowCount","getTopLevelRowCount","showingRootNode","childrenAfterFilter","getTopLevelRowDisplayedIndex","topLevelIndex","childrenAfterSort","isGroupHideOpenParents","getRowBounds","onRowGroupOpened","isAnimateRows","event","afterDataChange","FILTER","SORT","getType","ROW_MODEL_TYPE_CLIENT_SIDE","isPivotActive","AGGREGATE","createChangePath","rowNodeTransactions","noTransactions","missingOrEmpty","isTreeData","setInactive","isSuppressModelUpdateAfterUpdateTransaction","params","transWithAddsOrDeletes","filter","tx","add","remove","transactionsContainUpdatesOnly","doRowGrouping","groupState","rowNodeOrder","doFilter","doPivot","doAggregate","doSort","doRowsToDisplay","type","EVENT_MODEL_UPDATED","api","newData","newPage","dispatchEvent","$scope","window","setTimeout","$apply","isEmpty","rowsMissing","isReady","isRowsToRender","exists","getNodesInRangeForSelection","firstInRange","lastInRange","firstRowHit","lastRowHit","result","groupsSelectChildren","isGroupSelectsChildren","forEachNodeAfterFilterAndSort","lookingForLastRow","skipThisGroupNode","group","inRange","childOfLastRow","isParentOfNode","push","setDatasource","datasource","console","error","getTopLevelNodes","getRootNode","isRowPresent","indexOf","pixelToMatch","bottomPointer","topPointer","lastNode","last","midPointer","floor","currentRowNode","isRowInPixel","topPixel","bottomPixel","pixelInRow","forEachLeafNode","callback","forEachNode","recursivelyWalkNodesAndCallback","Normal","forEachNodeAfterFilter","AfterFilter","AfterFilterAndSort","forEachPivotNode","PivotNodes","nodes","recursionType","node","nodeChildren","leafGroup","aggregationStage","execute","expandOrCollapseAll","expand","usingTreeData","recursiveExpandOrCollapse","shouldExpandOrCollapse","eventSource","EVENT_EXPAND_COLLAPSE_ALL","source","sortStage","groupStage","removeGroupsFromSelection","restoreGroupState","updateGroupsFromChildrenSelections","updateHasChildren","traverseNodesWithKey","filterStage","pivotStage","getGroupState","isRememberGroupStateWhenNewData","getCopyOfNodesMap","getRowNode","idIsGroup","ID_PREFIX_ROW_GROUP","res_1","undefined","rowDataChangedEvent","EVENT_ROW_DATA_CHANGED","batchUpdateRowData","rowDataTransaction","applyAsyncTransactionsTimeout","rowDataTransactionBatch","waitMillis","getAsyncTransactionWaitMillis","executeBatchUpdateRowData","flushAsyncTransactions","clearTimeout","valueCache","onDataChanged","callbackFuncsBound","rowNodeTrans","forceRowNodeOrder","tranItem","rowNodeTran","updateRowData","addIndex","commonUpdateRowData","func","event_1","getApi","getColumnApi","EVENT_ASYNC_TRANSACTIONS_FLUSHED","results","rowDataTran","createRowNodeOrder","suppressSortOrder","isSuppressMaintainUnsortedOrder","orderMap","EVENT_ROW_DATA_UPDATED","flattenStage","onRowHeightChanged","resetRowHeights","atLeastOne"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { _, Autowired, Bean, BeanStub, ChangedPath, Constants, Events, GridOptionsWrapper, Optional, PostConstruct, ClientSideRowModelSteps, RowNode, RowHighlightPosition } from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager\";\nvar RecursionType;\n(function (RecursionType) {\n    RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n    RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n    RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n    RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n})(RecursionType || (RecursionType = {}));\nvar ClientSideRowModel = /** @class */ (function (_super) {\n    __extends(ClientSideRowModel, _super);\n    function ClientSideRowModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ClientSideRowModel.prototype.init = function () {\n        var refreshEverythingFunc = this.refreshModel.bind(this, { step: ClientSideRowModelSteps.EVERYTHING });\n        var refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.EVERYTHING,\n            afterColumnsChanged: true,\n            keepRenderedRows: true,\n            animate: true\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: ClientSideRowModelSteps.PIVOT }));\n        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n        var refreshMapListener = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.MAP,\n            keepRenderedRows: true,\n            animate: true\n        });\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapListener);\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapListener);\n        this.rootNode = new RowNode();\n        this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsWrapper, this.getContext(), this.eventService, this.columnModel, this.gridApi, this.columnApi, this.selectionService);\n        this.createBean(this.rootNode);\n    };\n    ClientSideRowModel.prototype.start = function () {\n        var rowData = this.gridOptionsWrapper.getRowData();\n        if (rowData) {\n            this.setRowData(rowData);\n        }\n    };\n    ClientSideRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) {\n        var atLeastOneChange;\n        var res = false;\n        // we do this multiple times as changing the row heights can also change the first and last rows,\n        // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n        // more rows.\n        do {\n            atLeastOneChange = false;\n            var rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n            var rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n            // keep check to current page if doing pagination\n            var firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n            var lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n            for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n                var rowNode = this.getRow(rowIndex);\n                if (rowNode.rowHeightEstimated) {\n                    var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);\n                    rowNode.setRowHeight(rowHeight.height);\n                    atLeastOneChange = true;\n                    res = true;\n                }\n            }\n            if (atLeastOneChange) {\n                this.setRowTopAndRowIndex();\n            }\n        } while (atLeastOneChange);\n        return res;\n    };\n    ClientSideRowModel.prototype.setRowTopAndRowIndex = function () {\n        var nextRowTop = 0;\n        for (var i = 0; i < this.rowsToDisplay.length; i++) {\n            // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n            // with these two layouts.\n            var allowEstimate = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n            var rowNode = this.rowsToDisplay[i];\n            if (_.missing(rowNode.rowHeight)) {\n                var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode, allowEstimate);\n                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n            }\n            rowNode.setRowTop(nextRowTop);\n            rowNode.setRowIndex(i);\n            nextRowTop += rowNode.rowHeight;\n        }\n    };\n    ClientSideRowModel.prototype.clearRowTopAndRowIndex = function (changedPath) {\n        var displayedRowsMapped = {};\n        this.rowsToDisplay.forEach(function (rowNode) {\n            if (rowNode.id != null) {\n                displayedRowsMapped[rowNode.id] = rowNode;\n            }\n        });\n        var clearIfNotDisplayed = function (rowNode) {\n            if (rowNode && rowNode.id != null && displayedRowsMapped[rowNode.id] == null) {\n                rowNode.clearRowTopAndRowIndex();\n            }\n        };\n        var recurse = function (rowNode) {\n            clearIfNotDisplayed(rowNode);\n            clearIfNotDisplayed(rowNode.detailNode);\n            clearIfNotDisplayed(rowNode.sibling);\n            if (rowNode.hasChildren()) {\n                if (rowNode.childrenAfterGroup) {\n                    // if a changedPath is active, it means we are here because of a transaction update or\n                    // a change detection. neither of these impacts the open/closed state of groups. so if\n                    // a group is not open this time, it was not open last time. so we know all closed groups\n                    // already have their top positions cleared. so there is no need to traverse all the way\n                    // when changedPath is active and the rowNode is not expanded.\n                    var isRootNode = rowNode.level == -1; // we need to give special consideration for root node,\n                    // as expanded=undefined for root node\n                    var skipChildren = changedPath.isActive() && !isRootNode && !rowNode.expanded;\n                    if (!skipChildren) {\n                        rowNode.childrenAfterGroup.forEach(recurse);\n                    }\n                }\n            }\n        };\n        recurse(this.rootNode);\n    };\n    // returns false if row was moved, otherwise true\n    ClientSideRowModel.prototype.ensureRowsAtPixel = function (rowNodes, pixel, increment) {\n        var _this = this;\n        if (increment === void 0) { increment = 0; }\n        var indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n        var rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n        if (rowNodeAtPixelNow === rowNodes[0]) {\n            return false;\n        }\n        rowNodes.forEach(function (rowNode) {\n            _.removeFromArray(_this.rootNode.allLeafChildren, rowNode);\n        });\n        rowNodes.forEach(function (rowNode, idx) {\n            _.insertIntoArray(_this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n        });\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            keepRenderedRows: true,\n            animate: true,\n            keepEditingRows: true\n        });\n        return true;\n    };\n    ClientSideRowModel.prototype.highlightRowAtPixel = function (rowNode, pixel) {\n        var indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n        var rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n        if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n            if (this.lastHighlightedRow) {\n                this.lastHighlightedRow.setHighlighted(null);\n                this.lastHighlightedRow = null;\n            }\n            return;\n        }\n        var highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n        if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n            this.lastHighlightedRow.setHighlighted(null);\n            this.lastHighlightedRow = null;\n        }\n        rowNodeAtPixelNow.setHighlighted(highlight);\n        this.lastHighlightedRow = rowNodeAtPixelNow;\n    };\n    ClientSideRowModel.prototype.getHighlightPosition = function (pixel, rowNode) {\n        if (!rowNode) {\n            var index = this.getRowIndexAtPixel(pixel);\n            rowNode = this.getRow(index || 0);\n            if (!rowNode) {\n                return RowHighlightPosition.Below;\n            }\n        }\n        var rowTop = rowNode.rowTop, rowHeight = rowNode.rowHeight;\n        return pixel - rowTop < rowHeight / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n    };\n    ClientSideRowModel.prototype.getLastHighlightedRowNode = function () {\n        return this.lastHighlightedRow;\n    };\n    ClientSideRowModel.prototype.isLastRowIndexKnown = function () {\n        return true;\n    };\n    ClientSideRowModel.prototype.getRowCount = function () {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length;\n        }\n        return 0;\n    };\n    ClientSideRowModel.prototype.getTopLevelRowCount = function () {\n        var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return 1;\n        }\n        return this.rootNode.childrenAfterFilter ? this.rootNode.childrenAfterFilter.length : 0;\n    };\n    ClientSideRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return topLevelIndex;\n        }\n        var rowNode = this.rootNode.childrenAfterSort[topLevelIndex];\n        if (this.gridOptionsWrapper.isGroupHideOpenParents()) {\n            // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n            while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n                rowNode = rowNode.childrenAfterSort[0];\n            }\n        }\n        return rowNode.rowIndex;\n    };\n    ClientSideRowModel.prototype.getRowBounds = function (index) {\n        if (_.missing(this.rowsToDisplay)) {\n            return null;\n        }\n        var rowNode = this.rowsToDisplay[index];\n        if (rowNode) {\n            return {\n                rowTop: rowNode.rowTop,\n                rowHeight: rowNode.rowHeight\n            };\n        }\n        return null;\n    };\n    ClientSideRowModel.prototype.onRowGroupOpened = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onFilterChanged = function (event) {\n        if (event.afterDataChange) {\n            return;\n        }\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.FILTER, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onSortChanged = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.SORT, keepRenderedRows: true, animate: animate, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.getType = function () {\n        return Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n    };\n    ClientSideRowModel.prototype.onValueChanged = function () {\n        if (this.columnModel.isPivotActive()) {\n            this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n        }\n        else {\n            this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n        }\n    };\n    ClientSideRowModel.prototype.createChangePath = function (rowNodeTransactions) {\n        // for updates, if the row is updated at all, then we re-calc all the values\n        // in that row. we could compare each value to each old value, however if we\n        // did this, we would be calling the valueService twice, once on the old value\n        // and once on the new value. so it's less valueGetter calls if we just assume\n        // each column is different. that way the changedPath is used so that only\n        // the impacted parent rows are recalculated, parents who's children have\n        // not changed are not impacted.\n        var noTransactions = _.missingOrEmpty(rowNodeTransactions);\n        var changedPath = new ChangedPath(false, this.rootNode);\n        if (noTransactions || this.gridOptionsWrapper.isTreeData()) {\n            changedPath.setInactive();\n        }\n        return changedPath;\n    };\n    ClientSideRowModel.prototype.isSuppressModelUpdateAfterUpdateTransaction = function (params) {\n        if (!this.gridOptionsWrapper.isSuppressModelUpdateAfterUpdateTransaction()) {\n            return false;\n        }\n        // return true if we are only doing update transactions\n        if (params.rowNodeTransactions == null) {\n            return false;\n        }\n        var transWithAddsOrDeletes = _.filter(params.rowNodeTransactions, function (tx) {\n            return (tx.add != null && tx.add.length > 0) || (tx.remove != null && tx.remove.length > 0);\n        });\n        var transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n        return transactionsContainUpdatesOnly;\n    };\n    ClientSideRowModel.prototype.refreshModel = function (params) {\n        var _this = this;\n        if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) {\n            return;\n        }\n        // this goes through the pipeline of stages. what's in my head is similar\n        // to the diagram on this page:\n        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n        // however we want to keep the results of each stage, hence we manually call\n        // each step rather than have them chain each other.\n        // fallthrough in below switch is on purpose,\n        // eg if STEP_FILTER, then all steps below this\n        // step get done\n        // let start: number;\n        // console.log('======= start =======');\n        var changedPath = this.createChangePath(params.rowNodeTransactions);\n        switch (params.step) {\n            case ClientSideRowModelSteps.EVERYTHING:\n                this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, !!params.afterColumnsChanged);\n            case ClientSideRowModelSteps.FILTER:\n                this.doFilter(changedPath);\n            case ClientSideRowModelSteps.PIVOT:\n                this.doPivot(changedPath);\n            case ClientSideRowModelSteps.AGGREGATE: // depends on agg fields\n                this.doAggregate(changedPath);\n            case ClientSideRowModelSteps.SORT:\n                this.doSort(params.rowNodeTransactions, changedPath);\n            case ClientSideRowModelSteps.MAP:\n                this.doRowsToDisplay();\n        }\n        // set all row tops to null, then set row tops on all visible rows. if we don't\n        // do this, then the algorithm below only sets row tops, old row tops from old rows\n        // will still lie around\n        this.setRowTopAndRowIndex();\n        this.clearRowTopAndRowIndex(changedPath);\n        var event = {\n            type: Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            animate: params.animate,\n            keepRenderedRows: params.keepRenderedRows,\n            newData: params.newData,\n            newPage: false\n        };\n        this.eventService.dispatchEvent(event);\n        if (this.$scope) {\n            window.setTimeout(function () {\n                _this.$scope.$apply();\n            }, 0);\n        }\n    };\n    ClientSideRowModel.prototype.isEmpty = function () {\n        var rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n        return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n    };\n    ClientSideRowModel.prototype.isRowsToRender = function () {\n        return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n    };\n    ClientSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n        // if lastSelectedNode is missing, we start at the first row\n        var firstRowHit = !lastInRange;\n        var lastRowHit = false;\n        var lastRow;\n        var result = [];\n        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.forEachNodeAfterFilterAndSort(function (rowNode) {\n            var lookingForLastRow = firstRowHit && !lastRowHit;\n            // check if we need to flip the select switch\n            if (!firstRowHit) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    firstRowHit = true;\n                }\n            }\n            var skipThisGroupNode = rowNode.group && groupsSelectChildren;\n            if (!skipThisGroupNode) {\n                var inRange = firstRowHit && !lastRowHit;\n                var childOfLastRow = rowNode.isParentOfNode(lastRow);\n                if (inRange || childOfLastRow) {\n                    result.push(rowNode);\n                }\n            }\n            if (lookingForLastRow) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    lastRowHit = true;\n                    if (rowNode === lastInRange) {\n                        lastRow = lastInRange;\n                    }\n                    else {\n                        lastRow = firstInRange;\n                    }\n                }\n            }\n        });\n        return result;\n    };\n    ClientSideRowModel.prototype.setDatasource = function (datasource) {\n        console.error('AG Grid: should never call setDatasource on clientSideRowController');\n    };\n    ClientSideRowModel.prototype.getTopLevelNodes = function () {\n        return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n    };\n    ClientSideRowModel.prototype.getRootNode = function () {\n        return this.rootNode;\n    };\n    ClientSideRowModel.prototype.getRow = function (index) {\n        return this.rowsToDisplay[index];\n    };\n    ClientSideRowModel.prototype.isRowPresent = function (rowNode) {\n        return this.rowsToDisplay.indexOf(rowNode) >= 0;\n    };\n    ClientSideRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        // do binary search of tree\n        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n        var bottomPointer = 0;\n        var topPointer = this.rowsToDisplay.length - 1;\n        // quick check, if the pixel is out of bounds, then return last row\n        if (pixelToMatch <= 0) {\n            // if pixel is less than or equal zero, it's always the first row\n            return 0;\n        }\n        var lastNode = _.last(this.rowsToDisplay);\n        if (lastNode.rowTop <= pixelToMatch) {\n            return this.rowsToDisplay.length - 1;\n        }\n        while (true) {\n            var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            var currentRowNode = this.rowsToDisplay[midPointer];\n            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n                return midPointer;\n            }\n            if (currentRowNode.rowTop < pixelToMatch) {\n                bottomPointer = midPointer + 1;\n            }\n            else if (currentRowNode.rowTop > pixelToMatch) {\n                topPointer = midPointer - 1;\n            }\n        }\n    };\n    ClientSideRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {\n        var topPixel = rowNode.rowTop;\n        var bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n        var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n        return pixelInRow;\n    };\n    ClientSideRowModel.prototype.forEachLeafNode = function (callback) {\n        if (this.rootNode.allLeafChildren) {\n            this.rootNode.allLeafChildren.forEach(function (rowNode, index) { return callback(rowNode, index); });\n        }\n    };\n    ClientSideRowModel.prototype.forEachNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilter = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);\n    };\n    ClientSideRowModel.prototype.forEachPivotNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);\n    };\n    // iterates through each item in memory, and calls the callback function\n    // nodes - the rowNodes to traverse\n    // callback - the user provided callback\n    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n    // index - works similar to the index in forEach in javascript's array function\n    ClientSideRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {\n        if (!nodes) {\n            return index;\n        }\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            callback(node, index++);\n            // go to the next level if it is a group\n            if (node.hasChildren()) {\n                // depending on the recursion type, we pick a difference set of children\n                var nodeChildren = null;\n                switch (recursionType) {\n                    case RecursionType.Normal:\n                        nodeChildren = node.childrenAfterGroup;\n                        break;\n                    case RecursionType.AfterFilter:\n                        nodeChildren = node.childrenAfterFilter;\n                        break;\n                    case RecursionType.AfterFilterAndSort:\n                        nodeChildren = node.childrenAfterSort;\n                        break;\n                    case RecursionType.PivotNodes:\n                        // for pivot, we don't go below leafGroup levels\n                        nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n                        break;\n                }\n                if (nodeChildren) {\n                    index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);\n                }\n            }\n        }\n        return index;\n    };\n    // it's possible to recompute the aggregate without doing the other parts\n    // + gridApi.recomputeAggregates()\n    ClientSideRowModel.prototype.doAggregate = function (changedPath) {\n        if (this.aggregationStage) {\n            this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    // + gridApi.expandAll()\n    // + gridApi.collapseAll()\n    ClientSideRowModel.prototype.expandOrCollapseAll = function (expand) {\n        var usingTreeData = this.gridOptionsWrapper.isTreeData();\n        if (this.rootNode) {\n            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n        }\n        function recursiveExpandOrCollapse(rowNodes) {\n            if (!rowNodes) {\n                return;\n            }\n            rowNodes.forEach(function (rowNode) {\n                var shouldExpandOrCollapse = usingTreeData ? _.exists(rowNode.childrenAfterGroup) : rowNode.group;\n                if (shouldExpandOrCollapse) {\n                    rowNode.expanded = expand;\n                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n                }\n            });\n        }\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n        var eventSource = expand ? 'expandAll' : 'collapseAll';\n        var event = {\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n            source: eventSource\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doSort = function (rowNodeTransactions, changedPath) {\n        this.sortStage.execute({\n            rowNode: this.rootNode,\n            rowNodeTransactions: rowNodeTransactions,\n            changedPath: changedPath\n        });\n    };\n    ClientSideRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {\n        if (this.groupStage) {\n            if (rowNodeTransactions) {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    rowNodeTransactions: rowNodeTransactions,\n                    rowNodeOrder: rowNodeOrder,\n                    changedPath: changedPath\n                });\n            }\n            else {\n                // groups are about to get disposed, so need to deselect any that are selected\n                this.selectionService.removeGroupsFromSelection();\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    changedPath: changedPath,\n                    afterColumnsChanged: afterColumnsChanged\n                });\n                // set open/closed state on groups\n                this.restoreGroupState(groupState);\n            }\n            if (this.gridOptionsWrapper.isGroupSelectsChildren()) {\n                this.selectionService.updateGroupsFromChildrenSelections(changedPath);\n            }\n        }\n        else {\n            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n            this.rootNode.updateHasChildren();\n        }\n    };\n    ClientSideRowModel.prototype.restoreGroupState = function (groupState) {\n        if (!groupState) {\n            return;\n        }\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n            // if the group was open last time, then open it this time. however\n            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n            // setting will take effect.\n            if (typeof groupState[key] === 'boolean') {\n                node.expanded = groupState[key];\n            }\n        });\n    };\n    ClientSideRowModel.prototype.doFilter = function (changedPath) {\n        this.filterStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    };\n    ClientSideRowModel.prototype.doPivot = function (changedPath) {\n        if (this.pivotStage) {\n            this.pivotStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    ClientSideRowModel.prototype.getGroupState = function () {\n        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {\n            return null;\n        }\n        var result = {};\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) { return result[key] = node.expanded; });\n        return result;\n    };\n    ClientSideRowModel.prototype.getCopyOfNodesMap = function () {\n        return this.nodeManager.getCopyOfNodesMap();\n    };\n    ClientSideRowModel.prototype.getRowNode = function (id) {\n        // although id is typed a string, this could be called by the user, and they could have passed a number\n        var idIsGroup = typeof id == 'string' && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;\n        if (idIsGroup) {\n            // only one users complained about getRowNode not working for groups, after years of\n            // this working for normal rows. so have done quick implementation. if users complain\n            // about performance, then GroupStage should store / manage created groups in a map,\n            // which is a chunk of work.\n            var res_1 = undefined;\n            this.forEachNode(function (node) {\n                if (node.id === id) {\n                    res_1 = node;\n                }\n            });\n            return res_1;\n        }\n        else {\n            return this.nodeManager.getRowNode(id);\n        }\n    };\n    // rows: the rows to put into the model\n    ClientSideRowModel.prototype.setRowData = function (rowData) {\n        // no need to invalidate cache, as the cache is stored on the rowNode,\n        // so new rowNodes means the cache is wiped anyway.\n        // remember group state, so we can expand groups that should be expanded\n        var groupState = this.getGroupState();\n        this.nodeManager.setRowData(rowData);\n        // this event kicks off:\n        // - clears selection\n        // - updates filters\n        // - shows 'no rows' overlay if needed\n        var rowDataChangedEvent = {\n            type: Events.EVENT_ROW_DATA_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(rowDataChangedEvent);\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            groupState: groupState,\n            newData: true\n        });\n    };\n    ClientSideRowModel.prototype.batchUpdateRowData = function (rowDataTransaction, callback) {\n        var _this = this;\n        if (this.applyAsyncTransactionsTimeout == null) {\n            this.rowDataTransactionBatch = [];\n            var waitMillis = this.gridOptionsWrapper.getAsyncTransactionWaitMillis();\n            this.applyAsyncTransactionsTimeout = window.setTimeout(function () {\n                _this.executeBatchUpdateRowData();\n            }, waitMillis);\n        }\n        this.rowDataTransactionBatch.push({ rowDataTransaction: rowDataTransaction, callback: callback });\n    };\n    ClientSideRowModel.prototype.flushAsyncTransactions = function () {\n        if (this.applyAsyncTransactionsTimeout != null) {\n            clearTimeout(this.applyAsyncTransactionsTimeout);\n            this.executeBatchUpdateRowData();\n        }\n    };\n    ClientSideRowModel.prototype.executeBatchUpdateRowData = function () {\n        var _this = this;\n        this.valueCache.onDataChanged();\n        var callbackFuncsBound = [];\n        var rowNodeTrans = [];\n        // The rowGroup stage uses rowNodeOrder if order was provided. if we didn't pass 'true' to\n        // commonUpdateRowData, using addIndex would have no effect when grouping.\n        var forceRowNodeOrder = false;\n        if (this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch.forEach(function (tranItem) {\n                var rowNodeTran = _this.nodeManager.updateRowData(tranItem.rowDataTransaction, undefined);\n                rowNodeTrans.push(rowNodeTran);\n                if (tranItem.callback) {\n                    callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n                }\n                if (typeof tranItem.rowDataTransaction.addIndex === 'number') {\n                    forceRowNodeOrder = true;\n                }\n            });\n        }\n        this.commonUpdateRowData(rowNodeTrans, undefined, forceRowNodeOrder);\n        // do callbacks in next VM turn so it's async\n        if (callbackFuncsBound.length > 0) {\n            window.setTimeout(function () {\n                callbackFuncsBound.forEach(function (func) { return func(); });\n            }, 0);\n        }\n        if (rowNodeTrans.length > 0) {\n            var event_1 = {\n                api: this.gridOptionsWrapper.getApi(),\n                columnApi: this.gridOptionsWrapper.getColumnApi(),\n                type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n                results: rowNodeTrans\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        this.rowDataTransactionBatch = null;\n        this.applyAsyncTransactionsTimeout = undefined;\n    };\n    ClientSideRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n        this.valueCache.onDataChanged();\n        var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n        // if doing immutableData, addIndex is never present. however if doing standard transaction, and user\n        // provided addIndex, then this is used in updateRowData. However if doing Enterprise, then the rowGroup\n        // stage also uses the\n        var forceRowNodeOrder = typeof rowDataTran.addIndex === 'number';\n        this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);\n        return rowNodeTran;\n    };\n    ClientSideRowModel.prototype.createRowNodeOrder = function () {\n        var suppressSortOrder = this.gridOptionsWrapper.isSuppressMaintainUnsortedOrder();\n        if (suppressSortOrder) {\n            return;\n        }\n        var orderMap = {};\n        if (this.rootNode && this.rootNode.allLeafChildren) {\n            for (var index = 0; index < this.rootNode.allLeafChildren.length; index++) {\n                var node = this.rootNode.allLeafChildren[index];\n                orderMap[node.id] = index;\n            }\n        }\n        return orderMap;\n    };\n    // common to updateRowData and batchUpdateRowData\n    ClientSideRowModel.prototype.commonUpdateRowData = function (rowNodeTrans, rowNodeOrder, forceRowNodeOrder) {\n        if (forceRowNodeOrder) {\n            rowNodeOrder = this.createRowNodeOrder();\n        }\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            rowNodeTransactions: rowNodeTrans,\n            rowNodeOrder: rowNodeOrder,\n            keepRenderedRows: true,\n            animate: true,\n            keepEditingRows: true\n        });\n        var event = {\n            type: Events.EVENT_ROW_DATA_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doRowsToDisplay = function () {\n        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });\n    };\n    ClientSideRowModel.prototype.onRowHeightChanged = function () {\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.resetRowHeights = function () {\n        var atLeastOne = false;\n        this.forEachNode(function (rowNode) {\n            rowNode.setRowHeight(rowNode.rowHeight, true);\n            // we keep the height each row is at, however we set estimated=true rather than clear the height.\n            // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n            var detailNode = rowNode.detailNode;\n            if (detailNode) {\n                detailNode.setRowHeight(detailNode.rowHeight, true);\n            }\n            atLeastOne = true;\n        });\n        if (atLeastOne) {\n            this.onRowHeightChanged();\n        }\n    };\n    __decorate([\n        Autowired('columnModel')\n    ], ClientSideRowModel.prototype, \"columnModel\", void 0);\n    __decorate([\n        Autowired('$scope')\n    ], ClientSideRowModel.prototype, \"$scope\", void 0);\n    __decorate([\n        Autowired('selectionService')\n    ], ClientSideRowModel.prototype, \"selectionService\", void 0);\n    __decorate([\n        Autowired('valueCache')\n    ], ClientSideRowModel.prototype, \"valueCache\", void 0);\n    __decorate([\n        Autowired('columnApi')\n    ], ClientSideRowModel.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired('gridApi')\n    ], ClientSideRowModel.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired('animationFrameService')\n    ], ClientSideRowModel.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        Autowired('filterStage')\n    ], ClientSideRowModel.prototype, \"filterStage\", void 0);\n    __decorate([\n        Autowired('sortStage')\n    ], ClientSideRowModel.prototype, \"sortStage\", void 0);\n    __decorate([\n        Autowired('flattenStage')\n    ], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n    __decorate([\n        Optional('groupStage')\n    ], ClientSideRowModel.prototype, \"groupStage\", void 0);\n    __decorate([\n        Optional('aggregationStage')\n    ], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n    __decorate([\n        Optional('pivotStage')\n    ], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n    __decorate([\n        PostConstruct\n    ], ClientSideRowModel.prototype, \"init\", null);\n    ClientSideRowModel = __decorate([\n        Bean('rowModel')\n    ], ClientSideRowModel);\n    return ClientSideRowModel;\n}(BeanStub));\nexport { ClientSideRowModel };\n"]},"metadata":{},"sourceType":"module"}